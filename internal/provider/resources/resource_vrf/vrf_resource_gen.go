// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_vrf

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func VrfResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"advertise_default_route": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Flag to Control Advertisement of Default Route Internally",
				MarkdownDescription: "Flag to Control Advertisement of Default Route Internally",
				Default:             booldefault.StaticBool(true),
			},
			"advertise_host_routes": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Flag to Control Advertisement of /32 and /128 Routes to Edge Routers",
				MarkdownDescription: "Flag to Control Advertisement of /32 and /128 Routes to Edge Routers",
				Default:             booldefault.StaticBool(false),
			},
			"attachments": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"freeform_config": schema.StringAttribute{
							Optional:            true,
							Description:         "This field covers any configuration not included in overlay templates which is needed as part of this VRF attachment",
							MarkdownDescription: "This field covers any configuration not included in overlay templates which is needed as part of this VRF attachment",
						},
						"loopback_id": schema.Int64Attribute{
							Optional:            true,
							Description:         "Override loopback ID",
							MarkdownDescription: "Override loopback ID",
						},
						"loopback_ipv4": schema.StringAttribute{
							Optional:            true,
							Description:         "Override loopback IPv4 address",
							MarkdownDescription: "Override loopback IPv4 address",
						},
						"loopback_ipv6": schema.StringAttribute{
							Optional:            true,
							Description:         "Override loopback IPv6 address",
							MarkdownDescription: "Override loopback IPv6 address",
						},
						"serial_number": schema.StringAttribute{
							Required:            true,
							Description:         "Serial number of switch to attach",
							MarkdownDescription: "Serial number of switch to attach",
						},
						"vlan_id": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "Override VLAN ID. `-1` to use VLAN ID defined at VRF level",
							MarkdownDescription: "Override VLAN ID. `-1` to use VLAN ID defined at VRF level",
							Default:             int64default.StaticInt64(-1),
						},
					},
					CustomType: AttachmentsType{
						ObjectType: types.ObjectType{
							AttrTypes: AttachmentsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "A list of attachments",
				MarkdownDescription: "A list of attachments",
			},
			"bgp_password": schema.StringAttribute{
				Optional:            true,
				Description:         "VRF Lite BGP neighbor password (Hex String)",
				MarkdownDescription: "VRF Lite BGP neighbor password (Hex String)",
			},
			"bgp_password_type": schema.StringAttribute{
				Optional:            true,
				Description:         "VRF Lite BGP Key Encryption Type: 3 - 3DES, 7 - Cisco",
				MarkdownDescription: "VRF Lite BGP Key Encryption Type: 3 - 3DES, 7 - Cisco",
			},
			"configure_static_default_route": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Flag to Control Static Default Route Configuration",
				MarkdownDescription: "Flag to Control Static Default Route Configuration",
				Default:             booldefault.StaticBool(true),
			},
			"deploy_attachments": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Deploy all attachments in this VRF",
				MarkdownDescription: "Deploy all attachments in this VRF",
				Default:             booldefault.StaticBool(false),
			},
			"disable_rt_auto": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Applicable to IPv4, IPv6 VPN/EVPN/MVPN",
				MarkdownDescription: "Applicable to IPv4, IPv6 VPN/EVPN/MVPN",
				Default:             booldefault.StaticBool(false),
			},
			"fabric_name": schema.StringAttribute{
				Optional:            true,
				Description:         "The name of the fabric",
				MarkdownDescription: "The name of the fabric",
			},
			"id": schema.StringAttribute{
				Optional:            true,
				Description:         "ID",
				MarkdownDescription: "ID",
			},
			"interface_description": schema.StringAttribute{
				Optional:            true,
				Description:         "Interface description",
				MarkdownDescription: "Interface description",
			},
			"ipv6_link_local": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enables IPv6 link-local Option under VRF SVI",
				MarkdownDescription: "Enables IPv6 link-local Option under VRF SVI",
				Default:             booldefault.StaticBool(true),
			},
			"loopback_routing_tag": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Loopback routing tag",
				MarkdownDescription: "Loopback routing tag",
				Default:             int64default.StaticInt64(12345),
			},
			"max_bgp_paths": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Maximum BGP paths",
				MarkdownDescription: "Maximum BGP paths",
				Default:             int64default.StaticInt64(1),
			},
			"max_ibgp_paths": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Maximum iBGP paths",
				MarkdownDescription: "Maximum iBGP paths",
				Default:             int64default.StaticInt64(2),
			},
			"mtu": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Interface MTU",
				MarkdownDescription: "Interface MTU",
				Default:             int64default.StaticInt64(9216),
			},
			"mvpn_inter_as": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Use the inter-as keyword for the MVPN address family routes to cross the BGP autonomous system (AS) boundaries, applicable when TRM is enabled. IOS XE Specific",
				MarkdownDescription: "Use the inter-as keyword for the MVPN address family routes to cross the BGP autonomous system (AS) boundaries, applicable when TRM is enabled. IOS XE Specific",
				Default:             booldefault.StaticBool(false),
			},
			"netflow": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "For netflow on VRF-LITE Sub-interface. Supported only if netflow is enabled on fabric. For NX-OS only",
				MarkdownDescription: "For netflow on VRF-LITE Sub-interface. Supported only if netflow is enabled on fabric. For NX-OS only",
				Default:             booldefault.StaticBool(false),
			},
			"netflow_monitor": schema.StringAttribute{
				Optional:            true,
				Description:         "Netflow monitor. For NX-OS only",
				MarkdownDescription: "Netflow monitor. For NX-OS only",
			},
			"no_rp": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "There is no RP as only SSM is used",
				MarkdownDescription: "There is no RP as only SSM is used",
				Default:             booldefault.StaticBool(false),
			},
			"overlay_multicast_groups": schema.StringAttribute{
				Optional:            true,
				Description:         "Overlay multicast groups",
				MarkdownDescription: "Overlay multicast groups",
			},
			"redistribute_direct_route_map": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Redistribute direct route map",
				MarkdownDescription: "Redistribute direct route map",
				Default:             stringdefault.StaticString("FABRIC-RMAP-REDIST-SUBNET"),
			},
			"route_target_export": schema.StringAttribute{
				Optional:            true,
				Description:         "For VPN Routes Export, One or a Comma Separated List",
				MarkdownDescription: "For VPN Routes Export, One or a Comma Separated List",
			},
			"route_target_export_cloud_evpn": schema.StringAttribute{
				Optional:            true,
				Description:         "For Cloud EVPN Routes Export, One or a Comma Separated List",
				MarkdownDescription: "For Cloud EVPN Routes Export, One or a Comma Separated List",
			},
			"route_target_export_evpn": schema.StringAttribute{
				Optional:            true,
				Description:         "For EVPN Routes Export, One or a Comma Separated List",
				MarkdownDescription: "For EVPN Routes Export, One or a Comma Separated List",
			},
			"route_target_export_mvpn": schema.StringAttribute{
				Optional:            true,
				Description:         "For MVPN Routes Export, One or a Comma Separated List",
				MarkdownDescription: "For MVPN Routes Export, One or a Comma Separated List",
			},
			"route_target_import": schema.StringAttribute{
				Optional:            true,
				Description:         "For VPN Routes Import, One or a Comma Separated List",
				MarkdownDescription: "For VPN Routes Import, One or a Comma Separated List",
			},
			"route_target_import_cloud_evpn": schema.StringAttribute{
				Optional:            true,
				Description:         "For Cloud EVPN Routes Import, One or a Comma Separated List",
				MarkdownDescription: "For Cloud EVPN Routes Import, One or a Comma Separated List",
			},
			"route_target_import_evpn": schema.StringAttribute{
				Optional:            true,
				Description:         "For EVPN Routes Import, One or a Comma Separated List",
				MarkdownDescription: "For EVPN Routes Import, One or a Comma Separated List",
			},
			"route_target_import_mvpn": schema.StringAttribute{
				Optional:            true,
				Description:         "For MVPN Routes Import, One or a Comma Separated List",
				MarkdownDescription: "For MVPN Routes Import, One or a Comma Separated List",
			},
			"rp_address": schema.StringAttribute{
				Optional:            true,
				Description:         "IPv4 address",
				MarkdownDescription: "IPv4 address",
			},
			"rp_external": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Is RP external to the fabric",
				MarkdownDescription: "Is RP external to the fabric",
				Default:             booldefault.StaticBool(false),
			},
			"rp_loopback_id": schema.Int64Attribute{
				Optional:            true,
				Description:         "RP loopback ID",
				MarkdownDescription: "RP loopback ID",
			},
			"trm": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable Tenant Routed Multicast",
				MarkdownDescription: "Enable Tenant Routed Multicast",
				Default:             booldefault.StaticBool(false),
			},
			"trm_bgw_msite": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enable TRM on Border Gateway Multisite",
				MarkdownDescription: "Enable TRM on Border Gateway Multisite",
				Default:             booldefault.StaticBool(false),
			},
			"underlay_multicast_address": schema.StringAttribute{
				Optional:            true,
				Description:         "IPv4 Multicast Address. Applicable only when TRM is enabled.",
				MarkdownDescription: "IPv4 Multicast Address. Applicable only when TRM is enabled.",
			},
			"vlan_id": schema.Int64Attribute{
				Computed:            true,
				Description:         "VLAN ID",
				MarkdownDescription: "VLAN ID",
			},
			"vlan_name": schema.StringAttribute{
				Optional:            true,
				Description:         "VLAN name",
				MarkdownDescription: "VLAN name",
			},
			"vrf_description": schema.StringAttribute{
				Optional:            true,
				Description:         "VRF description",
				MarkdownDescription: "VRF description",
			},
			"vrf_extension_template": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The name of the VRF extension template",
				MarkdownDescription: "The name of the VRF extension template",
				Default:             stringdefault.StaticString("Default_VRF_Extension_Universal"),
			},
			"vrf_id": schema.Int64Attribute{
				Computed:            true,
				Description:         "VNI ID of VRF",
				MarkdownDescription: "VNI ID of VRF",
			},
			"vrf_name": schema.StringAttribute{
				Required:            true,
				Description:         "The name of the VRF",
				MarkdownDescription: "The name of the VRF",
			},
			"vrf_template": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The name of the VRF template",
				MarkdownDescription: "The name of the VRF template",
				Default:             stringdefault.StaticString("Default_VRF_Universal"),
			},
		},
	}
}

type VrfModel struct {
	AdvertiseDefaultRoute       types.Bool   `tfsdk:"advertise_default_route"`
	AdvertiseHostRoutes         types.Bool   `tfsdk:"advertise_host_routes"`
	Attachments                 types.List   `tfsdk:"attachments"`
	BgpPassword                 types.String `tfsdk:"bgp_password"`
	BgpPasswordType             types.String `tfsdk:"bgp_password_type"`
	ConfigureStaticDefaultRoute types.Bool   `tfsdk:"configure_static_default_route"`
	DeployAttachments           types.Bool   `tfsdk:"deploy_attachments"`
	DisableRtAuto               types.Bool   `tfsdk:"disable_rt_auto"`
	FabricName                  types.String `tfsdk:"fabric_name"`
	Id                          types.String `tfsdk:"id"`
	InterfaceDescription        types.String `tfsdk:"interface_description"`
	Ipv6LinkLocal               types.Bool   `tfsdk:"ipv6_link_local"`
	LoopbackRoutingTag          types.Int64  `tfsdk:"loopback_routing_tag"`
	MaxBgpPaths                 types.Int64  `tfsdk:"max_bgp_paths"`
	MaxIbgpPaths                types.Int64  `tfsdk:"max_ibgp_paths"`
	Mtu                         types.Int64  `tfsdk:"mtu"`
	MvpnInterAs                 types.Bool   `tfsdk:"mvpn_inter_as"`
	Netflow                     types.Bool   `tfsdk:"netflow"`
	NetflowMonitor              types.String `tfsdk:"netflow_monitor"`
	NoRp                        types.Bool   `tfsdk:"no_rp"`
	OverlayMulticastGroups      types.String `tfsdk:"overlay_multicast_groups"`
	RedistributeDirectRouteMap  types.String `tfsdk:"redistribute_direct_route_map"`
	RouteTargetExport           types.String `tfsdk:"route_target_export"`
	RouteTargetExportCloudEvpn  types.String `tfsdk:"route_target_export_cloud_evpn"`
	RouteTargetExportEvpn       types.String `tfsdk:"route_target_export_evpn"`
	RouteTargetExportMvpn       types.String `tfsdk:"route_target_export_mvpn"`
	RouteTargetImport           types.String `tfsdk:"route_target_import"`
	RouteTargetImportCloudEvpn  types.String `tfsdk:"route_target_import_cloud_evpn"`
	RouteTargetImportEvpn       types.String `tfsdk:"route_target_import_evpn"`
	RouteTargetImportMvpn       types.String `tfsdk:"route_target_import_mvpn"`
	RpAddress                   types.String `tfsdk:"rp_address"`
	RpExternal                  types.Bool   `tfsdk:"rp_external"`
	RpLoopbackId                types.Int64  `tfsdk:"rp_loopback_id"`
	Trm                         types.Bool   `tfsdk:"trm"`
	TrmBgwMsite                 types.Bool   `tfsdk:"trm_bgw_msite"`
	UnderlayMulticastAddress    types.String `tfsdk:"underlay_multicast_address"`
	VlanId                      types.Int64  `tfsdk:"vlan_id"`
	VlanName                    types.String `tfsdk:"vlan_name"`
	VrfDescription              types.String `tfsdk:"vrf_description"`
	VrfExtensionTemplate        types.String `tfsdk:"vrf_extension_template"`
	VrfId                       types.Int64  `tfsdk:"vrf_id"`
	VrfName                     types.String `tfsdk:"vrf_name"`
	VrfTemplate                 types.String `tfsdk:"vrf_template"`
}

var _ basetypes.ObjectTypable = AttachmentsType{}

type AttachmentsType struct {
	basetypes.ObjectType
}

func (t AttachmentsType) Equal(o attr.Type) bool {
	other, ok := o.(AttachmentsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AttachmentsType) String() string {
	return "AttachmentsType"
}

func (t AttachmentsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	freeformConfigAttribute, ok := attributes["freeform_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`freeform_config is missing from object`)

		return nil, diags
	}

	freeformConfigVal, ok := freeformConfigAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`freeform_config expected to be basetypes.StringValue, was: %T`, freeformConfigAttribute))
	}

	loopbackIdAttribute, ok := attributes["loopback_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`loopback_id is missing from object`)

		return nil, diags
	}

	loopbackIdVal, ok := loopbackIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`loopback_id expected to be basetypes.Int64Value, was: %T`, loopbackIdAttribute))
	}

	loopbackIpv4Attribute, ok := attributes["loopback_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`loopback_ipv4 is missing from object`)

		return nil, diags
	}

	loopbackIpv4Val, ok := loopbackIpv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`loopback_ipv4 expected to be basetypes.StringValue, was: %T`, loopbackIpv4Attribute))
	}

	loopbackIpv6Attribute, ok := attributes["loopback_ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`loopback_ipv6 is missing from object`)

		return nil, diags
	}

	loopbackIpv6Val, ok := loopbackIpv6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`loopback_ipv6 expected to be basetypes.StringValue, was: %T`, loopbackIpv6Attribute))
	}

	serialNumberAttribute, ok := attributes["serial_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`serial_number is missing from object`)

		return nil, diags
	}

	serialNumberVal, ok := serialNumberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`serial_number expected to be basetypes.StringValue, was: %T`, serialNumberAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AttachmentsValue{
		FreeformConfig: freeformConfigVal,
		LoopbackId:     loopbackIdVal,
		LoopbackIpv4:   loopbackIpv4Val,
		LoopbackIpv6:   loopbackIpv6Val,
		SerialNumber:   serialNumberVal,
		VlanId:         vlanIdVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAttachmentsValueNull() AttachmentsValue {
	return AttachmentsValue{
		state: attr.ValueStateNull,
	}
}

func NewAttachmentsValueUnknown() AttachmentsValue {
	return AttachmentsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAttachmentsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AttachmentsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AttachmentsValue Attribute Value",
				"While creating a AttachmentsValue value, a missing attribute value was detected. "+
					"A AttachmentsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttachmentsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AttachmentsValue Attribute Type",
				"While creating a AttachmentsValue value, an invalid attribute value was detected. "+
					"A AttachmentsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttachmentsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AttachmentsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AttachmentsValue Attribute Value",
				"While creating a AttachmentsValue value, an extra attribute value was detected. "+
					"A AttachmentsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AttachmentsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAttachmentsValueUnknown(), diags
	}

	freeformConfigAttribute, ok := attributes["freeform_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`freeform_config is missing from object`)

		return NewAttachmentsValueUnknown(), diags
	}

	freeformConfigVal, ok := freeformConfigAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`freeform_config expected to be basetypes.StringValue, was: %T`, freeformConfigAttribute))
	}

	loopbackIdAttribute, ok := attributes["loopback_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`loopback_id is missing from object`)

		return NewAttachmentsValueUnknown(), diags
	}

	loopbackIdVal, ok := loopbackIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`loopback_id expected to be basetypes.Int64Value, was: %T`, loopbackIdAttribute))
	}

	loopbackIpv4Attribute, ok := attributes["loopback_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`loopback_ipv4 is missing from object`)

		return NewAttachmentsValueUnknown(), diags
	}

	loopbackIpv4Val, ok := loopbackIpv4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`loopback_ipv4 expected to be basetypes.StringValue, was: %T`, loopbackIpv4Attribute))
	}

	loopbackIpv6Attribute, ok := attributes["loopback_ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`loopback_ipv6 is missing from object`)

		return NewAttachmentsValueUnknown(), diags
	}

	loopbackIpv6Val, ok := loopbackIpv6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`loopback_ipv6 expected to be basetypes.StringValue, was: %T`, loopbackIpv6Attribute))
	}

	serialNumberAttribute, ok := attributes["serial_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`serial_number is missing from object`)

		return NewAttachmentsValueUnknown(), diags
	}

	serialNumberVal, ok := serialNumberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`serial_number expected to be basetypes.StringValue, was: %T`, serialNumberAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewAttachmentsValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return NewAttachmentsValueUnknown(), diags
	}

	return AttachmentsValue{
		FreeformConfig: freeformConfigVal,
		LoopbackId:     loopbackIdVal,
		LoopbackIpv4:   loopbackIpv4Val,
		LoopbackIpv6:   loopbackIpv6Val,
		SerialNumber:   serialNumberVal,
		VlanId:         vlanIdVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAttachmentsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AttachmentsValue {
	object, diags := NewAttachmentsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAttachmentsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AttachmentsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAttachmentsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAttachmentsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAttachmentsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAttachmentsValueMust(t.AttrTypes, attributes), nil
}

func (t AttachmentsType) ValueType(ctx context.Context) attr.Value {
	return AttachmentsValue{}
}

var _ basetypes.ObjectValuable = AttachmentsValue{}

type AttachmentsValue struct {
	FreeformConfig basetypes.StringValue `tfsdk:"freeform_config"`
	LoopbackId     basetypes.Int64Value  `tfsdk:"loopback_id"`
	LoopbackIpv4   basetypes.StringValue `tfsdk:"loopback_ipv4"`
	LoopbackIpv6   basetypes.StringValue `tfsdk:"loopback_ipv6"`
	SerialNumber   basetypes.StringValue `tfsdk:"serial_number"`
	VlanId         basetypes.Int64Value  `tfsdk:"vlan_id"`
	state          attr.ValueState
}

func (v AttachmentsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["freeform_config"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["loopback_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["loopback_ipv4"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["loopback_ipv6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["serial_number"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.FreeformConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["freeform_config"] = val

		val, err = v.LoopbackId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["loopback_id"] = val

		val, err = v.LoopbackIpv4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["loopback_ipv4"] = val

		val, err = v.LoopbackIpv6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["loopback_ipv6"] = val

		val, err = v.SerialNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["serial_number"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AttachmentsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AttachmentsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AttachmentsValue) String() string {
	return "AttachmentsValue"
}

func (v AttachmentsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"freeform_config": basetypes.StringType{},
			"loopback_id":     basetypes.Int64Type{},
			"loopback_ipv4":   basetypes.StringType{},
			"loopback_ipv6":   basetypes.StringType{},
			"serial_number":   basetypes.StringType{},
			"vlan_id":         basetypes.Int64Type{},
		},
		map[string]attr.Value{
			"freeform_config": v.FreeformConfig,
			"loopback_id":     v.LoopbackId,
			"loopback_ipv4":   v.LoopbackIpv4,
			"loopback_ipv6":   v.LoopbackIpv6,
			"serial_number":   v.SerialNumber,
			"vlan_id":         v.VlanId,
		})

	return objVal, diags
}

func (v AttachmentsValue) Equal(o attr.Value) bool {
	other, ok := o.(AttachmentsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FreeformConfig.Equal(other.FreeformConfig) {
		return false
	}

	if !v.LoopbackId.Equal(other.LoopbackId) {
		return false
	}

	if !v.LoopbackIpv4.Equal(other.LoopbackIpv4) {
		return false
	}

	if !v.LoopbackIpv6.Equal(other.LoopbackIpv6) {
		return false
	}

	if !v.SerialNumber.Equal(other.SerialNumber) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	return true
}

func (v AttachmentsValue) Type(ctx context.Context) attr.Type {
	return AttachmentsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AttachmentsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"freeform_config": basetypes.StringType{},
		"loopback_id":     basetypes.Int64Type{},
		"loopback_ipv4":   basetypes.StringType{},
		"loopback_ipv6":   basetypes.StringType{},
		"serial_number":   basetypes.StringType{},
		"vlan_id":         basetypes.Int64Type{},
	}
}
