// Copyright (c) 2024 Cisco Systems, Inc. and its affiliates
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.
//
// SPDX-License-Identifier: MPL-2.0

package resource_vrf_bulk

// This is not autogenerated code. DONOT DELETE this file when auto generating code
// This is a custom code that is used to manipulate the data in the NDFC VRF vrfPayloads
// Mapping functions to convert NDFC payload back to model structs

import (
	"encoding/json"
	"log"
	"terraform-provider-ndfc/internal/provider/resources/resource_vrf_attachments"
	rva "terraform-provider-ndfc/internal/provider/resources/resource_vrf_attachments"
	. "terraform-provider-ndfc/internal/provider/types"
)

type CustomCNDFCVrfsValue NDFCVrfsValue

// Skip Attachlist in payload
func (v NDFCVrfsValue) MarshalJSON() ([]byte, error) {
	v1 := CustomCNDFCVrfsValue{}
	v1.Id = v.Id
	v1.VrfName = v.VrfName
	v1.VrfId = v.VrfId
	v1.FabricName = v.FabricName
	v1.VrfTemplate = v.VrfTemplate
	v1.VrfExtensionTemplate = v.VrfExtensionTemplate
	v1.VrfStatus = v.VrfStatus
	v1.VrfTemplateConfig = v.VrfTemplateConfig
	v1.AttachList = nil //v.AttachList
	return json.Marshal(&v1)
}

type NDFCBulkVrfPayload struct {
	Vrfs []NDFCVrfsValue `json:"vrfs"`
}

func (v *NDFCVrfBulkModel) AddVrfEntry(vrfName string, vrfEntry NDFCVrfsValue) {
	v.Vrfs[vrfName] = vrfEntry
}

func (v NDFCVrfBulkModel) GetVrfNames() []string {
	vrfNames := make([]string, 0)
	for k := range v.Vrfs {
		vrfNames = append(vrfNames, k)
	}
	return vrfNames
}

func (v NDFCVrfBulkModel) GetVrfValues() []NDFCVrfsValue {
	vrfValues := make([]NDFCVrfsValue, 0)
	for _, v := range v.Vrfs {
		vrfValues = append(vrfValues, v)
	}
	return vrfValues
}

func (v NDFCVrfBulkModel) GetAttachmentNames(vrf string) []string {
	attachmentNames := make([]string, 0)
	vrfEntry, ok := v.Vrfs[vrf]
	if ok {
		for k := range vrfEntry.AttachList {
			attachmentNames = append(attachmentNames, k)
		}
	}
	return attachmentNames
}

func (v NDFCVrfBulkModel) GetAttachmentValues(vrf string) []rva.NDFCAttachListValue {
	attachmentValues := make([]rva.NDFCAttachListValue, 0)
	vrfEntry, ok := v.Vrfs[vrf]
	if ok {
		for _, v := range vrfEntry.AttachList {
			attachmentValues = append(attachmentValues, v)
		}

	}
	return attachmentValues
}

func (v NDFCVrfsValue) GetAttachmentValues(filters uint16, attach string) []rva.NDFCAttachListValue {
	log.Printf("GetAttachmentValues: %s %s", v.VrfName, v.FabricName)
	update := func(a *rva.NDFCAttachListValue, serial string) {
		log.Printf("GetAttachmentValues: update %s %s", v.VrfName, v.FabricName)
		a.FabricName = v.FabricName
		a.VrfName = v.VrfName
		a.SerialNumber = serial
		if a.Vlan == nil {
			a.Vlan = new(Int64Custom)
			*a.Vlan = Int64Custom(-1)
		}
		if attach != "" {
			a.Deployment = attach
		}
	}
	attachmentValues := make([]rva.NDFCAttachListValue, 0)
	for serial, attachEntry := range v.AttachList {
		if filters != 0 {
			if attachEntry.UpdateAction&filters != 0 {
				update(&attachEntry, serial)
				attachmentValues = append(attachmentValues, attachEntry)
			}
		} else {
			update(&attachEntry, serial)
			attachmentValues = append(attachmentValues, attachEntry)
		}

	}
	return attachmentValues
}

func (v *NDFCVrfBulkModel) FillVrfsFromPayload(payload *NDFCBulkVrfPayload) {
	v.Vrfs = make(map[string]NDFCVrfsValue)
	vrfPresent := false
	for i := range payload.Vrfs {
		vrfPresent = true
		v.Vrfs[payload.Vrfs[i].VrfName] = payload.Vrfs[i]
	}
	if vrfPresent {
		v.FabricName = payload.Vrfs[0].FabricName
	}
}

func (v *NDFCVrfBulkModel) FillVrfPayloadFromModel(depMap *map[string][]string) *NDFCBulkVrfPayload {
	payload := new(NDFCBulkVrfPayload)
	payload.Vrfs = make([]NDFCVrfsValue, 0)
	for vrfName, vrfEntry := range v.Vrfs {
		vrfEntry.FabricName = v.FabricName
		vrfEntry.VrfName = vrfName
		payload.Vrfs = append(payload.Vrfs, vrfEntry)
		if depMap != nil {
			if vrfEntry.DeployAttachments {
				(*depMap)[vrfName] = append((*depMap)[vrfName], vrfName)

			}
		}
	}
	return payload
}

func (v *NDFCVrfBulkModel) FillAttachmentsFromPayload(payload *rva.NDFCVrfAttachmentsPayloads) {
	for i := range (*payload).VrfAttachments {
		vrfName := (*payload).VrfAttachments[i].VrfName
		attachList := (*payload).VrfAttachments[i].AttachList
		vrfEntry, ok := v.Vrfs[vrfName]
		if ok {
			vrfEntry.AttachList = make(map[string]rva.NDFCAttachListValue)
			for j := range attachList {
				vrfEntry.AttachList[attachList[j].SwitchSerialNo] = attachList[j]
			}
			//put it back
			v.Vrfs[vrfName] = vrfEntry
		}
	}
}

/*  AttachPayloadFromModel - This function is used to convert the NDFC VRF model Payload
 *  Fill all required payload fields
 *  Fill Deployment flag in DepMap
 */
func (v *NDFCVrfBulkModel) FillAttachPayloadFromModel(delFlag bool) *rva.NDFCVrfAttachmentsPayloads {
	payload := new(rva.NDFCVrfAttachmentsPayloads)
	payload.VrfAttachments = make([]rva.NDFCVrfAttachmentsPayload, 0)
	payload.DepMap = make(map[string][]string)
	payload.FabricName = v.FabricName

	if v.DeployAllAttachments {
		payload.DepMap["global"] = []string{"all"}
	}

	if delFlag {
		payload.DepMap["global"] = []string{"all"}
		v.DeployAllAttachments = true
	}

	for vrfName, vrfEntry := range v.Vrfs {
		vrfEntry.VrfName = vrfName
		vrfEntry.FabricName = v.FabricName
		var vrfAttachVal *rva.NDFCVrfAttachmentsPayload
		if vrfEntry.DeployAttachments {
			payload.DepMap[vrfName] = append(payload.DepMap[vrfName], vrfName)
		}
		log.Printf("DeployAllAttachments %s/%v", vrfName, vrfEntry.DeployAttachments)

		if len(vrfEntry.AttachList) > 0 {
			vrfAttachVal = new(resource_vrf_attachments.NDFCVrfAttachmentsPayload)
			vrfAttachVal.VrfName = vrfName
		}
		for attachKey, attachEntry := range vrfEntry.AttachList {
			attachEntry.SerialNumber = attachKey
			attachEntry.FabricName = v.FabricName
			attachEntry.VrfName = vrfName

			if attachEntry.DeployThisAttachment {
				payload.DepMap[vrfName] = append(payload.DepMap[vrfName], attachKey)
			}
			log.Printf("DeployThisAttachment %s/%s", vrfName, attachKey)
			if delFlag {
				attachEntry.Deployment = "false"
			} else {
				attachEntry.Deployment = "true"
			}

			/* NDFCBUG: throws 500 Server error if vlan field is empty */
			/* Setting to -1 to avoid this - UI does the same */
			if attachEntry.Vlan == nil {
				attachEntry.Vlan = new(Int64Custom)
				*attachEntry.Vlan = Int64Custom(-1)
			}
			//put modified entry back
			vrfEntry.AttachList[attachKey] = attachEntry
			vrfAttachVal.AttachList = append(vrfAttachVal.AttachList, attachEntry)
		}
		//put modified entry back
		v.Vrfs[vrfName] = vrfEntry
		if vrfAttachVal != nil {
			payload.VrfAttachments = append(payload.VrfAttachments, *vrfAttachVal)
		}
	}
	return payload
}
