// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_networks

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func NetworksResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"deploy_all_attachments": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Deploy all attachments in this resource",
				MarkdownDescription: "Deploy all attachments in this resource",
				Default:             booldefault.StaticBool(false),
			},
			"fabric_name": schema.StringAttribute{
				Required:            true,
				Description:         "The name of the fabric",
				MarkdownDescription: "The name of the fabric",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"id": schema.StringAttribute{
				Computed:            true,
				Description:         "Terraform unique Id for the resource",
				MarkdownDescription: "Terraform unique Id for the resource",
			},
			"networks": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"arp_suppression": schema.BoolAttribute{
							Optional:            true,
							Description:         "ARP suppression is only supported if SVI is present when Layer-2-Only is not enabled. NX-OS Specific.",
							MarkdownDescription: "ARP suppression is only supported if SVI is present when Layer-2-Only is not enabled. NX-OS Specific.",
						},
						"attachments": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"attach_state": schema.StringAttribute{
										Computed:            true,
										Description:         "The state of the attachment",
										MarkdownDescription: "The state of the attachment",
									},
									"attached": schema.BoolAttribute{
										Computed:            true,
										Description:         "The state of the attachment",
										MarkdownDescription: "The state of the attachment",
									},
									"deploy_this_attachment": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Deploy this attachment",
										MarkdownDescription: "Deploy this attachment",
										Default:             booldefault.StaticBool(false),
									},
									"display_name": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "The name of the switch",
										MarkdownDescription: "The name of the switch",
									},
									"freeform_config": schema.StringAttribute{
										Optional:            true,
										Description:         "This field covers any configuration not included in overlay templates which is needed as part of this VRF attachment",
										MarkdownDescription: "This field covers any configuration not included in overlay templates which is needed as part of this VRF attachment",
									},
									"instance_values": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Instance values",
										MarkdownDescription: "Instance values",
									},
									"switch_name": schema.StringAttribute{
										Computed:            true,
										Description:         "The name of the switch",
										MarkdownDescription: "The name of the switch",
									},
									"switch_ports": schema.SetAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "List of switch ports",
										MarkdownDescription: "List of switch ports",
									},
									"tor_ports": schema.SetAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Computed:            true,
										Description:         "List of TOR ports",
										MarkdownDescription: "List of TOR ports",
									},
									"vlan": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "VLAN ID",
										MarkdownDescription: "VLAN ID",
										PlanModifiers: []planmodifier.Int64{
											int64planmodifier.UseStateForUnknown(),
										},
									},
								},
								CustomType: AttachmentsType{
									ObjectType: types.ObjectType{
										AttrTypes: AttachmentsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "List of switches attached to the net",
							MarkdownDescription: "List of switches attached to the net",
						},
						"deploy_attachments": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Deploy all attachments in this network",
							MarkdownDescription: "Deploy all attachments in this network",
							Default:             booldefault.StaticBool(false),
						},
						"dhcp_relay_loopback_id": schema.Int64Attribute{
							Optional:            true,
							Description:         "Loopback ID for DHCP Relay interface",
							MarkdownDescription: "Loopback ID for DHCP Relay interface",
						},
						"dhcp_relay_servers": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"address": schema.StringAttribute{
										Optional:            true,
										Description:         "Server IP V4 Address",
										MarkdownDescription: "Server IP V4 Address",
									},
									"vrf": schema.StringAttribute{
										Optional:            true,
										Description:         "Server VRF. If management vrf, enter 'management'. If default/global vrf, enter 'default'.",
										MarkdownDescription: "Server VRF. If management vrf, enter 'management'. If default/global vrf, enter 'default'.",
									},
								},
								CustomType: DhcpRelayServersType{
									ObjectType: types.ObjectType{
										AttrTypes: DhcpRelayServersValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "List of DHCP relay servers",
							MarkdownDescription: "List of DHCP relay servers",
						},
						"display_name": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Customized name of the network. By default, it will be same as the network name",
							MarkdownDescription: "Customized name of the network. By default, it will be same as the network name",
						},
						"gateway_ipv4_address": schema.StringAttribute{
							Optional:            true,
							Description:         "Gateway IPv4 address, for example `192.0.2.1/24`",
							MarkdownDescription: "Gateway IPv4 address, for example `192.0.2.1/24`",
						},
						"gateway_ipv6_address": schema.StringAttribute{
							Optional:            true,
							Description:         "Gateway IPv6 addresses, for example `2001:db8::1/64,2001:db9::1/64`",
							MarkdownDescription: "Gateway IPv6 addresses, for example `2001:db8::1/64,2001:db9::1/64`",
						},
						"igmp_version": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "IGMP version",
							MarkdownDescription: "IGMP version",
						},
						"ingress_replication": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Ingress replication flag. Read-only per network, Fabric-wide setting.",
							MarkdownDescription: "Ingress replication flag. Read-only per network, Fabric-wide setting.",
							Default:             booldefault.StaticBool(false),
						},
						"interface_description": schema.StringAttribute{
							Optional:            true,
							Description:         "Interface description",
							MarkdownDescription: "Interface description",
						},
						"l3_gatway_border": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Enable L3 Gateway on Border",
							MarkdownDescription: "Enable L3 Gateway on Border",
							Default:             booldefault.StaticBool(false),
						},
						"layer2_only": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Layer-2 only flag",
							MarkdownDescription: "Layer-2 only flag",
							Default:             booldefault.StaticBool(false),
						},
						"mtu": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "MTU for L3 interface",
							MarkdownDescription: "MTU for L3 interface",
							Default:             int64default.StaticInt64(9216),
						},
						"multicast_group": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Multicast group address",
							MarkdownDescription: "Multicast group address",
						},
						"netflow": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Netflow enable flag. Netflow is supported only if it is enabled on fabric. For NX-OS only.",
							MarkdownDescription: "Netflow enable flag. Netflow is supported only if it is enabled on fabric. For NX-OS only.",
							Default:             booldefault.StaticBool(false),
						},
						"network_extension_template": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "The name of the network extension template. Applicable to Switch(es) with role Border",
							MarkdownDescription: "The name of the network extension template. Applicable to Switch(es) with role Border",
							Default:             stringdefault.StaticString("Default_Network_Extension_Universal"),
						},
						"network_id": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "VNI ID of the network",
							MarkdownDescription: "VNI ID of the network",
							PlanModifiers: []planmodifier.Int64{
								int64planmodifier.UseStateForUnknown(),
							},
						},
						"network_status": schema.StringAttribute{
							Computed:            true,
							Description:         "Network status",
							MarkdownDescription: "Network status",
						},
						"network_template": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "The name of the network template. This is only applicable for leaf switches",
							MarkdownDescription: "The name of the network template. This is only applicable for leaf switches",
							Default:             stringdefault.StaticString("Default_Network_Universal"),
						},
						"network_type": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Network Type",
							MarkdownDescription: "Network Type",
							Default:             stringdefault.StaticString("Normal"),
						},
						"primary_network_id": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "Primary network VNI ID. This is applicable only when PVLAN is enabled in fabric.",
							MarkdownDescription: "Primary network VNI ID. This is applicable only when PVLAN is enabled in fabric.",
							PlanModifiers: []planmodifier.Int64{
								int64planmodifier.UseStateForUnknown(),
							},
						},
						"route_target_both": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "L2 VNI Route-Target Both Enable. NX-OS specific.",
							MarkdownDescription: "L2 VNI Route-Target Both Enable. NX-OS specific.",
							Default:             booldefault.StaticBool(false),
						},
						"routing_tag": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "Routing tag",
							MarkdownDescription: "Routing tag",
							Default:             int64default.StaticInt64(12345),
						},
						"secondary_gateway_1": schema.StringAttribute{
							Optional:            true,
							Description:         "IPv4 Secondary GW1",
							MarkdownDescription: "IPv4 Secondary GW1",
						},
						"secondary_gateway_2": schema.StringAttribute{
							Optional:            true,
							Description:         "IPv4 Secondary GW2",
							MarkdownDescription: "IPv4 Secondary GW2",
						},
						"secondary_gateway_3": schema.StringAttribute{
							Optional:            true,
							Description:         "IPv4 Secondary GW3",
							MarkdownDescription: "IPv4 Secondary GW3",
						},
						"secondary_gateway_4": schema.StringAttribute{
							Optional:            true,
							Description:         "IPv4 Secondary GW4",
							MarkdownDescription: "IPv4 Secondary GW4",
						},
						"svi_netflow_monitor": schema.StringAttribute{
							Optional:            true,
							Description:         "Interface Vlan Netflow Monitor. Applicable only if 'Layer 2 Only' is not enabled. Provide monitor name defined in fabric setting for Layer 3 Record. For NX-OS only.",
							MarkdownDescription: "Interface Vlan Netflow Monitor. Applicable only if 'Layer 2 Only' is not enabled. Provide monitor name defined in fabric setting for Layer 3 Record. For NX-OS only.",
						},
						"trm": schema.BoolAttribute{
							Optional:            true,
							Description:         "Enable Tenant Routed Multicast",
							MarkdownDescription: "Enable Tenant Routed Multicast",
						},
						"vlan_id": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "VLAN ID",
							MarkdownDescription: "VLAN ID",
							PlanModifiers: []planmodifier.Int64{
								int64planmodifier.UseStateForUnknown(),
							},
						},
						"vlan_name": schema.StringAttribute{
							Optional:            true,
							Description:         "Vlan name. If > 32 chars, enable 'system vlan long-name' for NX-OS, disable VTPv1 and VTPv2 or switch to VTPv3 for IOS XE.",
							MarkdownDescription: "Vlan name. If > 32 chars, enable 'system vlan long-name' for NX-OS, disable VTPv1 and VTPv2 or switch to VTPv3 for IOS XE.",
						},
						"vlan_netflow_monitor": schema.StringAttribute{
							Optional:            true,
							Description:         "Vlan Netflow Monitor. Provide monitor name defined in fabric setting for Layer 3 Record. For NX-OS only",
							MarkdownDescription: "Vlan Netflow Monitor. Provide monitor name defined in fabric setting for Layer 3 Record. For NX-OS only",
						},
						"vrf_name": schema.StringAttribute{
							Required:            true,
							Description:         "The name of the vrf",
							MarkdownDescription: "The name of the vrf",
						},
					},
					CustomType: NetworksType{
						ObjectType: types.ObjectType{
							AttrTypes: NetworksValue{}.AttributeTypes(ctx),
						},
					},
				},
				Required:            true,
				Description:         "List of networks",
				MarkdownDescription: "List of networks",
			},
		},
	}
}

type NetworksModel struct {
	DeployAllAttachments types.Bool   `tfsdk:"deploy_all_attachments"`
	FabricName           types.String `tfsdk:"fabric_name"`
	Id                   types.String `tfsdk:"id"`
	Networks             types.Map    `tfsdk:"networks"`
}

var _ basetypes.ObjectTypable = NetworksType{}

type NetworksType struct {
	basetypes.ObjectType
}

func (t NetworksType) Equal(o attr.Type) bool {
	other, ok := o.(NetworksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetworksType) String() string {
	return "NetworksType"
}

func (t NetworksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	arpSuppressionAttribute, ok := attributes["arp_suppression"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_suppression is missing from object`)

		return nil, diags
	}

	arpSuppressionVal, ok := arpSuppressionAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_suppression expected to be basetypes.BoolValue, was: %T`, arpSuppressionAttribute))
	}

	attachmentsAttribute, ok := attributes["attachments"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attachments is missing from object`)

		return nil, diags
	}

	attachmentsVal, ok := attachmentsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attachments expected to be basetypes.MapValue, was: %T`, attachmentsAttribute))
	}

	deployAttachmentsAttribute, ok := attributes["deploy_attachments"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deploy_attachments is missing from object`)

		return nil, diags
	}

	deployAttachmentsVal, ok := deployAttachmentsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deploy_attachments expected to be basetypes.BoolValue, was: %T`, deployAttachmentsAttribute))
	}

	dhcpRelayLoopbackIdAttribute, ok := attributes["dhcp_relay_loopback_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_relay_loopback_id is missing from object`)

		return nil, diags
	}

	dhcpRelayLoopbackIdVal, ok := dhcpRelayLoopbackIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_relay_loopback_id expected to be basetypes.Int64Value, was: %T`, dhcpRelayLoopbackIdAttribute))
	}

	dhcpRelayServersAttribute, ok := attributes["dhcp_relay_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_relay_servers is missing from object`)

		return nil, diags
	}

	dhcpRelayServersVal, ok := dhcpRelayServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_relay_servers expected to be basetypes.ListValue, was: %T`, dhcpRelayServersAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return nil, diags
	}

	displayNameVal, ok := displayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be basetypes.StringValue, was: %T`, displayNameAttribute))
	}

	gatewayIpv4AddressAttribute, ok := attributes["gateway_ipv4_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway_ipv4_address is missing from object`)

		return nil, diags
	}

	gatewayIpv4AddressVal, ok := gatewayIpv4AddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway_ipv4_address expected to be basetypes.StringValue, was: %T`, gatewayIpv4AddressAttribute))
	}

	gatewayIpv6AddressAttribute, ok := attributes["gateway_ipv6_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway_ipv6_address is missing from object`)

		return nil, diags
	}

	gatewayIpv6AddressVal, ok := gatewayIpv6AddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway_ipv6_address expected to be basetypes.StringValue, was: %T`, gatewayIpv6AddressAttribute))
	}

	igmpVersionAttribute, ok := attributes["igmp_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`igmp_version is missing from object`)

		return nil, diags
	}

	igmpVersionVal, ok := igmpVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`igmp_version expected to be basetypes.StringValue, was: %T`, igmpVersionAttribute))
	}

	ingressReplicationAttribute, ok := attributes["ingress_replication"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress_replication is missing from object`)

		return nil, diags
	}

	ingressReplicationVal, ok := ingressReplicationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress_replication expected to be basetypes.BoolValue, was: %T`, ingressReplicationAttribute))
	}

	interfaceDescriptionAttribute, ok := attributes["interface_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_description is missing from object`)

		return nil, diags
	}

	interfaceDescriptionVal, ok := interfaceDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_description expected to be basetypes.StringValue, was: %T`, interfaceDescriptionAttribute))
	}

	l3GatwayBorderAttribute, ok := attributes["l3_gatway_border"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_gatway_border is missing from object`)

		return nil, diags
	}

	l3GatwayBorderVal, ok := l3GatwayBorderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_gatway_border expected to be basetypes.BoolValue, was: %T`, l3GatwayBorderAttribute))
	}

	layer2OnlyAttribute, ok := attributes["layer2_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`layer2_only is missing from object`)

		return nil, diags
	}

	layer2OnlyVal, ok := layer2OnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`layer2_only expected to be basetypes.BoolValue, was: %T`, layer2OnlyAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return nil, diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	multicastGroupAttribute, ok := attributes["multicast_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multicast_group is missing from object`)

		return nil, diags
	}

	multicastGroupVal, ok := multicastGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multicast_group expected to be basetypes.StringValue, was: %T`, multicastGroupAttribute))
	}

	netflowAttribute, ok := attributes["netflow"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netflow is missing from object`)

		return nil, diags
	}

	netflowVal, ok := netflowAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netflow expected to be basetypes.BoolValue, was: %T`, netflowAttribute))
	}

	networkExtensionTemplateAttribute, ok := attributes["network_extension_template"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_extension_template is missing from object`)

		return nil, diags
	}

	networkExtensionTemplateVal, ok := networkExtensionTemplateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_extension_template expected to be basetypes.StringValue, was: %T`, networkExtensionTemplateAttribute))
	}

	networkIdAttribute, ok := attributes["network_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_id is missing from object`)

		return nil, diags
	}

	networkIdVal, ok := networkIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_id expected to be basetypes.Int64Value, was: %T`, networkIdAttribute))
	}

	networkStatusAttribute, ok := attributes["network_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_status is missing from object`)

		return nil, diags
	}

	networkStatusVal, ok := networkStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_status expected to be basetypes.StringValue, was: %T`, networkStatusAttribute))
	}

	networkTemplateAttribute, ok := attributes["network_template"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_template is missing from object`)

		return nil, diags
	}

	networkTemplateVal, ok := networkTemplateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_template expected to be basetypes.StringValue, was: %T`, networkTemplateAttribute))
	}

	networkTypeAttribute, ok := attributes["network_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_type is missing from object`)

		return nil, diags
	}

	networkTypeVal, ok := networkTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_type expected to be basetypes.StringValue, was: %T`, networkTypeAttribute))
	}

	primaryNetworkIdAttribute, ok := attributes["primary_network_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary_network_id is missing from object`)

		return nil, diags
	}

	primaryNetworkIdVal, ok := primaryNetworkIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary_network_id expected to be basetypes.Int64Value, was: %T`, primaryNetworkIdAttribute))
	}

	routeTargetBothAttribute, ok := attributes["route_target_both"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route_target_both is missing from object`)

		return nil, diags
	}

	routeTargetBothVal, ok := routeTargetBothAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route_target_both expected to be basetypes.BoolValue, was: %T`, routeTargetBothAttribute))
	}

	routingTagAttribute, ok := attributes["routing_tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routing_tag is missing from object`)

		return nil, diags
	}

	routingTagVal, ok := routingTagAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routing_tag expected to be basetypes.Int64Value, was: %T`, routingTagAttribute))
	}

	secondaryGateway1Attribute, ok := attributes["secondary_gateway_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary_gateway_1 is missing from object`)

		return nil, diags
	}

	secondaryGateway1Val, ok := secondaryGateway1Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary_gateway_1 expected to be basetypes.StringValue, was: %T`, secondaryGateway1Attribute))
	}

	secondaryGateway2Attribute, ok := attributes["secondary_gateway_2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary_gateway_2 is missing from object`)

		return nil, diags
	}

	secondaryGateway2Val, ok := secondaryGateway2Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary_gateway_2 expected to be basetypes.StringValue, was: %T`, secondaryGateway2Attribute))
	}

	secondaryGateway3Attribute, ok := attributes["secondary_gateway_3"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary_gateway_3 is missing from object`)

		return nil, diags
	}

	secondaryGateway3Val, ok := secondaryGateway3Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary_gateway_3 expected to be basetypes.StringValue, was: %T`, secondaryGateway3Attribute))
	}

	secondaryGateway4Attribute, ok := attributes["secondary_gateway_4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary_gateway_4 is missing from object`)

		return nil, diags
	}

	secondaryGateway4Val, ok := secondaryGateway4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary_gateway_4 expected to be basetypes.StringValue, was: %T`, secondaryGateway4Attribute))
	}

	sviNetflowMonitorAttribute, ok := attributes["svi_netflow_monitor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`svi_netflow_monitor is missing from object`)

		return nil, diags
	}

	sviNetflowMonitorVal, ok := sviNetflowMonitorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`svi_netflow_monitor expected to be basetypes.StringValue, was: %T`, sviNetflowMonitorAttribute))
	}

	trmAttribute, ok := attributes["trm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`trm is missing from object`)

		return nil, diags
	}

	trmVal, ok := trmAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`trm expected to be basetypes.BoolValue, was: %T`, trmAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	vlanNameAttribute, ok := attributes["vlan_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_name is missing from object`)

		return nil, diags
	}

	vlanNameVal, ok := vlanNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_name expected to be basetypes.StringValue, was: %T`, vlanNameAttribute))
	}

	vlanNetflowMonitorAttribute, ok := attributes["vlan_netflow_monitor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_netflow_monitor is missing from object`)

		return nil, diags
	}

	vlanNetflowMonitorVal, ok := vlanNetflowMonitorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_netflow_monitor expected to be basetypes.StringValue, was: %T`, vlanNetflowMonitorAttribute))
	}

	vrfNameAttribute, ok := attributes["vrf_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_name is missing from object`)

		return nil, diags
	}

	vrfNameVal, ok := vrfNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_name expected to be basetypes.StringValue, was: %T`, vrfNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetworksValue{
		ArpSuppression:           arpSuppressionVal,
		Attachments:              attachmentsVal,
		DeployAttachments:        deployAttachmentsVal,
		DhcpRelayLoopbackId:      dhcpRelayLoopbackIdVal,
		DhcpRelayServers:         dhcpRelayServersVal,
		DisplayName:              displayNameVal,
		GatewayIpv4Address:       gatewayIpv4AddressVal,
		GatewayIpv6Address:       gatewayIpv6AddressVal,
		IgmpVersion:              igmpVersionVal,
		IngressReplication:       ingressReplicationVal,
		InterfaceDescription:     interfaceDescriptionVal,
		L3GatwayBorder:           l3GatwayBorderVal,
		Layer2Only:               layer2OnlyVal,
		Mtu:                      mtuVal,
		MulticastGroup:           multicastGroupVal,
		Netflow:                  netflowVal,
		NetworkExtensionTemplate: networkExtensionTemplateVal,
		NetworkId:                networkIdVal,
		NetworkStatus:            networkStatusVal,
		NetworkTemplate:          networkTemplateVal,
		NetworkType:              networkTypeVal,
		PrimaryNetworkId:         primaryNetworkIdVal,
		RouteTargetBoth:          routeTargetBothVal,
		RoutingTag:               routingTagVal,
		SecondaryGateway1:        secondaryGateway1Val,
		SecondaryGateway2:        secondaryGateway2Val,
		SecondaryGateway3:        secondaryGateway3Val,
		SecondaryGateway4:        secondaryGateway4Val,
		SviNetflowMonitor:        sviNetflowMonitorVal,
		Trm:                      trmVal,
		VlanId:                   vlanIdVal,
		VlanName:                 vlanNameVal,
		VlanNetflowMonitor:       vlanNetflowMonitorVal,
		VrfName:                  vrfNameVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewNetworksValueNull() NetworksValue {
	return NetworksValue{
		state: attr.ValueStateNull,
	}
}

func NewNetworksValueUnknown() NetworksValue {
	return NetworksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetworksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetworksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetworksValue Attribute Value",
				"While creating a NetworksValue value, a missing attribute value was detected. "+
					"A NetworksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetworksValue Attribute Type",
				"While creating a NetworksValue value, an invalid attribute value was detected. "+
					"A NetworksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetworksValue Attribute Value",
				"While creating a NetworksValue value, an extra attribute value was detected. "+
					"A NetworksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetworksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetworksValueUnknown(), diags
	}

	arpSuppressionAttribute, ok := attributes["arp_suppression"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_suppression is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	arpSuppressionVal, ok := arpSuppressionAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_suppression expected to be basetypes.BoolValue, was: %T`, arpSuppressionAttribute))
	}

	attachmentsAttribute, ok := attributes["attachments"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attachments is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	attachmentsVal, ok := attachmentsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attachments expected to be basetypes.MapValue, was: %T`, attachmentsAttribute))
	}

	deployAttachmentsAttribute, ok := attributes["deploy_attachments"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deploy_attachments is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	deployAttachmentsVal, ok := deployAttachmentsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deploy_attachments expected to be basetypes.BoolValue, was: %T`, deployAttachmentsAttribute))
	}

	dhcpRelayLoopbackIdAttribute, ok := attributes["dhcp_relay_loopback_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_relay_loopback_id is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	dhcpRelayLoopbackIdVal, ok := dhcpRelayLoopbackIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_relay_loopback_id expected to be basetypes.Int64Value, was: %T`, dhcpRelayLoopbackIdAttribute))
	}

	dhcpRelayServersAttribute, ok := attributes["dhcp_relay_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_relay_servers is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	dhcpRelayServersVal, ok := dhcpRelayServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_relay_servers expected to be basetypes.ListValue, was: %T`, dhcpRelayServersAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	displayNameVal, ok := displayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be basetypes.StringValue, was: %T`, displayNameAttribute))
	}

	gatewayIpv4AddressAttribute, ok := attributes["gateway_ipv4_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway_ipv4_address is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	gatewayIpv4AddressVal, ok := gatewayIpv4AddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway_ipv4_address expected to be basetypes.StringValue, was: %T`, gatewayIpv4AddressAttribute))
	}

	gatewayIpv6AddressAttribute, ok := attributes["gateway_ipv6_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway_ipv6_address is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	gatewayIpv6AddressVal, ok := gatewayIpv6AddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway_ipv6_address expected to be basetypes.StringValue, was: %T`, gatewayIpv6AddressAttribute))
	}

	igmpVersionAttribute, ok := attributes["igmp_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`igmp_version is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	igmpVersionVal, ok := igmpVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`igmp_version expected to be basetypes.StringValue, was: %T`, igmpVersionAttribute))
	}

	ingressReplicationAttribute, ok := attributes["ingress_replication"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress_replication is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	ingressReplicationVal, ok := ingressReplicationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress_replication expected to be basetypes.BoolValue, was: %T`, ingressReplicationAttribute))
	}

	interfaceDescriptionAttribute, ok := attributes["interface_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_description is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	interfaceDescriptionVal, ok := interfaceDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_description expected to be basetypes.StringValue, was: %T`, interfaceDescriptionAttribute))
	}

	l3GatwayBorderAttribute, ok := attributes["l3_gatway_border"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3_gatway_border is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	l3GatwayBorderVal, ok := l3GatwayBorderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3_gatway_border expected to be basetypes.BoolValue, was: %T`, l3GatwayBorderAttribute))
	}

	layer2OnlyAttribute, ok := attributes["layer2_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`layer2_only is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	layer2OnlyVal, ok := layer2OnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`layer2_only expected to be basetypes.BoolValue, was: %T`, layer2OnlyAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	multicastGroupAttribute, ok := attributes["multicast_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multicast_group is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	multicastGroupVal, ok := multicastGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multicast_group expected to be basetypes.StringValue, was: %T`, multicastGroupAttribute))
	}

	netflowAttribute, ok := attributes["netflow"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netflow is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	netflowVal, ok := netflowAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netflow expected to be basetypes.BoolValue, was: %T`, netflowAttribute))
	}

	networkExtensionTemplateAttribute, ok := attributes["network_extension_template"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_extension_template is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	networkExtensionTemplateVal, ok := networkExtensionTemplateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_extension_template expected to be basetypes.StringValue, was: %T`, networkExtensionTemplateAttribute))
	}

	networkIdAttribute, ok := attributes["network_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_id is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	networkIdVal, ok := networkIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_id expected to be basetypes.Int64Value, was: %T`, networkIdAttribute))
	}

	networkStatusAttribute, ok := attributes["network_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_status is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	networkStatusVal, ok := networkStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_status expected to be basetypes.StringValue, was: %T`, networkStatusAttribute))
	}

	networkTemplateAttribute, ok := attributes["network_template"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_template is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	networkTemplateVal, ok := networkTemplateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_template expected to be basetypes.StringValue, was: %T`, networkTemplateAttribute))
	}

	networkTypeAttribute, ok := attributes["network_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_type is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	networkTypeVal, ok := networkTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_type expected to be basetypes.StringValue, was: %T`, networkTypeAttribute))
	}

	primaryNetworkIdAttribute, ok := attributes["primary_network_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary_network_id is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	primaryNetworkIdVal, ok := primaryNetworkIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary_network_id expected to be basetypes.Int64Value, was: %T`, primaryNetworkIdAttribute))
	}

	routeTargetBothAttribute, ok := attributes["route_target_both"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route_target_both is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	routeTargetBothVal, ok := routeTargetBothAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route_target_both expected to be basetypes.BoolValue, was: %T`, routeTargetBothAttribute))
	}

	routingTagAttribute, ok := attributes["routing_tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routing_tag is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	routingTagVal, ok := routingTagAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routing_tag expected to be basetypes.Int64Value, was: %T`, routingTagAttribute))
	}

	secondaryGateway1Attribute, ok := attributes["secondary_gateway_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary_gateway_1 is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	secondaryGateway1Val, ok := secondaryGateway1Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary_gateway_1 expected to be basetypes.StringValue, was: %T`, secondaryGateway1Attribute))
	}

	secondaryGateway2Attribute, ok := attributes["secondary_gateway_2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary_gateway_2 is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	secondaryGateway2Val, ok := secondaryGateway2Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary_gateway_2 expected to be basetypes.StringValue, was: %T`, secondaryGateway2Attribute))
	}

	secondaryGateway3Attribute, ok := attributes["secondary_gateway_3"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary_gateway_3 is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	secondaryGateway3Val, ok := secondaryGateway3Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary_gateway_3 expected to be basetypes.StringValue, was: %T`, secondaryGateway3Attribute))
	}

	secondaryGateway4Attribute, ok := attributes["secondary_gateway_4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary_gateway_4 is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	secondaryGateway4Val, ok := secondaryGateway4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary_gateway_4 expected to be basetypes.StringValue, was: %T`, secondaryGateway4Attribute))
	}

	sviNetflowMonitorAttribute, ok := attributes["svi_netflow_monitor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`svi_netflow_monitor is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	sviNetflowMonitorVal, ok := sviNetflowMonitorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`svi_netflow_monitor expected to be basetypes.StringValue, was: %T`, sviNetflowMonitorAttribute))
	}

	trmAttribute, ok := attributes["trm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`trm is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	trmVal, ok := trmAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`trm expected to be basetypes.BoolValue, was: %T`, trmAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	vlanNameAttribute, ok := attributes["vlan_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_name is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	vlanNameVal, ok := vlanNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_name expected to be basetypes.StringValue, was: %T`, vlanNameAttribute))
	}

	vlanNetflowMonitorAttribute, ok := attributes["vlan_netflow_monitor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_netflow_monitor is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	vlanNetflowMonitorVal, ok := vlanNetflowMonitorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_netflow_monitor expected to be basetypes.StringValue, was: %T`, vlanNetflowMonitorAttribute))
	}

	vrfNameAttribute, ok := attributes["vrf_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_name is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	vrfNameVal, ok := vrfNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_name expected to be basetypes.StringValue, was: %T`, vrfNameAttribute))
	}

	if diags.HasError() {
		return NewNetworksValueUnknown(), diags
	}

	return NetworksValue{
		ArpSuppression:           arpSuppressionVal,
		Attachments:              attachmentsVal,
		DeployAttachments:        deployAttachmentsVal,
		DhcpRelayLoopbackId:      dhcpRelayLoopbackIdVal,
		DhcpRelayServers:         dhcpRelayServersVal,
		DisplayName:              displayNameVal,
		GatewayIpv4Address:       gatewayIpv4AddressVal,
		GatewayIpv6Address:       gatewayIpv6AddressVal,
		IgmpVersion:              igmpVersionVal,
		IngressReplication:       ingressReplicationVal,
		InterfaceDescription:     interfaceDescriptionVal,
		L3GatwayBorder:           l3GatwayBorderVal,
		Layer2Only:               layer2OnlyVal,
		Mtu:                      mtuVal,
		MulticastGroup:           multicastGroupVal,
		Netflow:                  netflowVal,
		NetworkExtensionTemplate: networkExtensionTemplateVal,
		NetworkId:                networkIdVal,
		NetworkStatus:            networkStatusVal,
		NetworkTemplate:          networkTemplateVal,
		NetworkType:              networkTypeVal,
		PrimaryNetworkId:         primaryNetworkIdVal,
		RouteTargetBoth:          routeTargetBothVal,
		RoutingTag:               routingTagVal,
		SecondaryGateway1:        secondaryGateway1Val,
		SecondaryGateway2:        secondaryGateway2Val,
		SecondaryGateway3:        secondaryGateway3Val,
		SecondaryGateway4:        secondaryGateway4Val,
		SviNetflowMonitor:        sviNetflowMonitorVal,
		Trm:                      trmVal,
		VlanId:                   vlanIdVal,
		VlanName:                 vlanNameVal,
		VlanNetflowMonitor:       vlanNetflowMonitorVal,
		VrfName:                  vrfNameVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewNetworksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetworksValue {
	object, diags := NewNetworksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetworksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetworksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetworksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetworksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetworksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetworksValueMust(NetworksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetworksType) ValueType(ctx context.Context) attr.Value {
	return NetworksValue{}
}

var _ basetypes.ObjectValuable = NetworksValue{}

type NetworksValue struct {
	ArpSuppression           basetypes.BoolValue   `tfsdk:"arp_suppression"`
	Attachments              basetypes.MapValue    `tfsdk:"attachments"`
	DeployAttachments        basetypes.BoolValue   `tfsdk:"deploy_attachments"`
	DhcpRelayLoopbackId      basetypes.Int64Value  `tfsdk:"dhcp_relay_loopback_id"`
	DhcpRelayServers         basetypes.ListValue   `tfsdk:"dhcp_relay_servers"`
	DisplayName              basetypes.StringValue `tfsdk:"display_name"`
	GatewayIpv4Address       basetypes.StringValue `tfsdk:"gateway_ipv4_address"`
	GatewayIpv6Address       basetypes.StringValue `tfsdk:"gateway_ipv6_address"`
	IgmpVersion              basetypes.StringValue `tfsdk:"igmp_version"`
	IngressReplication       basetypes.BoolValue   `tfsdk:"ingress_replication"`
	InterfaceDescription     basetypes.StringValue `tfsdk:"interface_description"`
	L3GatwayBorder           basetypes.BoolValue   `tfsdk:"l3_gatway_border"`
	Layer2Only               basetypes.BoolValue   `tfsdk:"layer2_only"`
	Mtu                      basetypes.Int64Value  `tfsdk:"mtu"`
	MulticastGroup           basetypes.StringValue `tfsdk:"multicast_group"`
	Netflow                  basetypes.BoolValue   `tfsdk:"netflow"`
	NetworkExtensionTemplate basetypes.StringValue `tfsdk:"network_extension_template"`
	NetworkId                basetypes.Int64Value  `tfsdk:"network_id"`
	NetworkStatus            basetypes.StringValue `tfsdk:"network_status"`
	NetworkTemplate          basetypes.StringValue `tfsdk:"network_template"`
	NetworkType              basetypes.StringValue `tfsdk:"network_type"`
	PrimaryNetworkId         basetypes.Int64Value  `tfsdk:"primary_network_id"`
	RouteTargetBoth          basetypes.BoolValue   `tfsdk:"route_target_both"`
	RoutingTag               basetypes.Int64Value  `tfsdk:"routing_tag"`
	SecondaryGateway1        basetypes.StringValue `tfsdk:"secondary_gateway_1"`
	SecondaryGateway2        basetypes.StringValue `tfsdk:"secondary_gateway_2"`
	SecondaryGateway3        basetypes.StringValue `tfsdk:"secondary_gateway_3"`
	SecondaryGateway4        basetypes.StringValue `tfsdk:"secondary_gateway_4"`
	SviNetflowMonitor        basetypes.StringValue `tfsdk:"svi_netflow_monitor"`
	Trm                      basetypes.BoolValue   `tfsdk:"trm"`
	VlanId                   basetypes.Int64Value  `tfsdk:"vlan_id"`
	VlanName                 basetypes.StringValue `tfsdk:"vlan_name"`
	VlanNetflowMonitor       basetypes.StringValue `tfsdk:"vlan_netflow_monitor"`
	VrfName                  basetypes.StringValue `tfsdk:"vrf_name"`
	state                    attr.ValueState
}

func (v NetworksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 34)

	var val tftypes.Value
	var err error

	attrTypes["arp_suppression"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["attachments"] = basetypes.MapType{
		ElemType: AttachmentsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["deploy_attachments"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["dhcp_relay_loopback_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["dhcp_relay_servers"] = basetypes.ListType{
		ElemType: DhcpRelayServersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gateway_ipv4_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gateway_ipv6_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["igmp_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ingress_replication"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["interface_description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["l3_gatway_border"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["layer2_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["multicast_group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netflow"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["network_extension_template"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["network_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["network_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["network_template"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["network_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["primary_network_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["route_target_both"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["routing_tag"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["secondary_gateway_1"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["secondary_gateway_2"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["secondary_gateway_3"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["secondary_gateway_4"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["svi_netflow_monitor"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["trm"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["vlan_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_netflow_monitor"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vrf_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 34)

		val, err = v.ArpSuppression.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["arp_suppression"] = val

		val, err = v.Attachments.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attachments"] = val

		val, err = v.DeployAttachments.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deploy_attachments"] = val

		val, err = v.DhcpRelayLoopbackId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_relay_loopback_id"] = val

		val, err = v.DhcpRelayServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_relay_servers"] = val

		val, err = v.DisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display_name"] = val

		val, err = v.GatewayIpv4Address.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway_ipv4_address"] = val

		val, err = v.GatewayIpv6Address.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway_ipv6_address"] = val

		val, err = v.IgmpVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["igmp_version"] = val

		val, err = v.IngressReplication.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ingress_replication"] = val

		val, err = v.InterfaceDescription.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_description"] = val

		val, err = v.L3GatwayBorder.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l3_gatway_border"] = val

		val, err = v.Layer2Only.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["layer2_only"] = val

		val, err = v.Mtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mtu"] = val

		val, err = v.MulticastGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["multicast_group"] = val

		val, err = v.Netflow.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netflow"] = val

		val, err = v.NetworkExtensionTemplate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network_extension_template"] = val

		val, err = v.NetworkId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network_id"] = val

		val, err = v.NetworkStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network_status"] = val

		val, err = v.NetworkTemplate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network_template"] = val

		val, err = v.NetworkType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network_type"] = val

		val, err = v.PrimaryNetworkId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["primary_network_id"] = val

		val, err = v.RouteTargetBoth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["route_target_both"] = val

		val, err = v.RoutingTag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["routing_tag"] = val

		val, err = v.SecondaryGateway1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secondary_gateway_1"] = val

		val, err = v.SecondaryGateway2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secondary_gateway_2"] = val

		val, err = v.SecondaryGateway3.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secondary_gateway_3"] = val

		val, err = v.SecondaryGateway4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secondary_gateway_4"] = val

		val, err = v.SviNetflowMonitor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["svi_netflow_monitor"] = val

		val, err = v.Trm.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["trm"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		val, err = v.VlanName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_name"] = val

		val, err = v.VlanNetflowMonitor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_netflow_monitor"] = val

		val, err = v.VrfName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetworksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetworksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetworksValue) String() string {
	return "NetworksValue"
}

func (v NetworksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attachments := types.MapValueMust(
		AttachmentsType{
			basetypes.ObjectType{
				AttrTypes: AttachmentsValue{}.AttributeTypes(ctx),
			},
		},
		v.Attachments.Elements(),
	)

	if v.Attachments.IsNull() {
		attachments = types.MapNull(
			AttachmentsType{
				basetypes.ObjectType{
					AttrTypes: AttachmentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Attachments.IsUnknown() {
		attachments = types.MapUnknown(
			AttachmentsType{
				basetypes.ObjectType{
					AttrTypes: AttachmentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	dhcpRelayServers := types.ListValueMust(
		DhcpRelayServersType{
			basetypes.ObjectType{
				AttrTypes: DhcpRelayServersValue{}.AttributeTypes(ctx),
			},
		},
		v.DhcpRelayServers.Elements(),
	)

	if v.DhcpRelayServers.IsNull() {
		dhcpRelayServers = types.ListNull(
			DhcpRelayServersType{
				basetypes.ObjectType{
					AttrTypes: DhcpRelayServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.DhcpRelayServers.IsUnknown() {
		dhcpRelayServers = types.ListUnknown(
			DhcpRelayServersType{
				basetypes.ObjectType{
					AttrTypes: DhcpRelayServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"arp_suppression": basetypes.BoolType{},
			"attachments": basetypes.MapType{
				ElemType: AttachmentsValue{}.Type(ctx),
			},
			"deploy_attachments":     basetypes.BoolType{},
			"dhcp_relay_loopback_id": basetypes.Int64Type{},
			"dhcp_relay_servers": basetypes.ListType{
				ElemType: DhcpRelayServersValue{}.Type(ctx),
			},
			"display_name":               basetypes.StringType{},
			"gateway_ipv4_address":       basetypes.StringType{},
			"gateway_ipv6_address":       basetypes.StringType{},
			"igmp_version":               basetypes.StringType{},
			"ingress_replication":        basetypes.BoolType{},
			"interface_description":      basetypes.StringType{},
			"l3_gatway_border":           basetypes.BoolType{},
			"layer2_only":                basetypes.BoolType{},
			"mtu":                        basetypes.Int64Type{},
			"multicast_group":            basetypes.StringType{},
			"netflow":                    basetypes.BoolType{},
			"network_extension_template": basetypes.StringType{},
			"network_id":                 basetypes.Int64Type{},
			"network_status":             basetypes.StringType{},
			"network_template":           basetypes.StringType{},
			"network_type":               basetypes.StringType{},
			"primary_network_id":         basetypes.Int64Type{},
			"route_target_both":          basetypes.BoolType{},
			"routing_tag":                basetypes.Int64Type{},
			"secondary_gateway_1":        basetypes.StringType{},
			"secondary_gateway_2":        basetypes.StringType{},
			"secondary_gateway_3":        basetypes.StringType{},
			"secondary_gateway_4":        basetypes.StringType{},
			"svi_netflow_monitor":        basetypes.StringType{},
			"trm":                        basetypes.BoolType{},
			"vlan_id":                    basetypes.Int64Type{},
			"vlan_name":                  basetypes.StringType{},
			"vlan_netflow_monitor":       basetypes.StringType{},
			"vrf_name":                   basetypes.StringType{},
		},
		map[string]attr.Value{
			"arp_suppression":            v.ArpSuppression,
			"attachments":                attachments,
			"deploy_attachments":         v.DeployAttachments,
			"dhcp_relay_loopback_id":     v.DhcpRelayLoopbackId,
			"dhcp_relay_servers":         dhcpRelayServers,
			"display_name":               v.DisplayName,
			"gateway_ipv4_address":       v.GatewayIpv4Address,
			"gateway_ipv6_address":       v.GatewayIpv6Address,
			"igmp_version":               v.IgmpVersion,
			"ingress_replication":        v.IngressReplication,
			"interface_description":      v.InterfaceDescription,
			"l3_gatway_border":           v.L3GatwayBorder,
			"layer2_only":                v.Layer2Only,
			"mtu":                        v.Mtu,
			"multicast_group":            v.MulticastGroup,
			"netflow":                    v.Netflow,
			"network_extension_template": v.NetworkExtensionTemplate,
			"network_id":                 v.NetworkId,
			"network_status":             v.NetworkStatus,
			"network_template":           v.NetworkTemplate,
			"network_type":               v.NetworkType,
			"primary_network_id":         v.PrimaryNetworkId,
			"route_target_both":          v.RouteTargetBoth,
			"routing_tag":                v.RoutingTag,
			"secondary_gateway_1":        v.SecondaryGateway1,
			"secondary_gateway_2":        v.SecondaryGateway2,
			"secondary_gateway_3":        v.SecondaryGateway3,
			"secondary_gateway_4":        v.SecondaryGateway4,
			"svi_netflow_monitor":        v.SviNetflowMonitor,
			"trm":                        v.Trm,
			"vlan_id":                    v.VlanId,
			"vlan_name":                  v.VlanName,
			"vlan_netflow_monitor":       v.VlanNetflowMonitor,
			"vrf_name":                   v.VrfName,
		})

	return objVal, diags
}

func (v NetworksValue) Equal(o attr.Value) bool {
	other, ok := o.(NetworksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ArpSuppression.Equal(other.ArpSuppression) {
		return false
	}

	if !v.Attachments.Equal(other.Attachments) {
		return false
	}

	if !v.DeployAttachments.Equal(other.DeployAttachments) {
		return false
	}

	if !v.DhcpRelayLoopbackId.Equal(other.DhcpRelayLoopbackId) {
		return false
	}

	if !v.DhcpRelayServers.Equal(other.DhcpRelayServers) {
		return false
	}

	if !v.DisplayName.Equal(other.DisplayName) {
		return false
	}

	if !v.GatewayIpv4Address.Equal(other.GatewayIpv4Address) {
		return false
	}

	if !v.GatewayIpv6Address.Equal(other.GatewayIpv6Address) {
		return false
	}

	if !v.IgmpVersion.Equal(other.IgmpVersion) {
		return false
	}

	if !v.IngressReplication.Equal(other.IngressReplication) {
		return false
	}

	if !v.InterfaceDescription.Equal(other.InterfaceDescription) {
		return false
	}

	if !v.L3GatwayBorder.Equal(other.L3GatwayBorder) {
		return false
	}

	if !v.Layer2Only.Equal(other.Layer2Only) {
		return false
	}

	if !v.Mtu.Equal(other.Mtu) {
		return false
	}

	if !v.MulticastGroup.Equal(other.MulticastGroup) {
		return false
	}

	if !v.Netflow.Equal(other.Netflow) {
		return false
	}

	if !v.NetworkExtensionTemplate.Equal(other.NetworkExtensionTemplate) {
		return false
	}

	if !v.NetworkId.Equal(other.NetworkId) {
		return false
	}

	if !v.NetworkStatus.Equal(other.NetworkStatus) {
		return false
	}

	if !v.NetworkTemplate.Equal(other.NetworkTemplate) {
		return false
	}

	if !v.NetworkType.Equal(other.NetworkType) {
		return false
	}

	if !v.PrimaryNetworkId.Equal(other.PrimaryNetworkId) {
		return false
	}

	if !v.RouteTargetBoth.Equal(other.RouteTargetBoth) {
		return false
	}

	if !v.RoutingTag.Equal(other.RoutingTag) {
		return false
	}

	if !v.SecondaryGateway1.Equal(other.SecondaryGateway1) {
		return false
	}

	if !v.SecondaryGateway2.Equal(other.SecondaryGateway2) {
		return false
	}

	if !v.SecondaryGateway3.Equal(other.SecondaryGateway3) {
		return false
	}

	if !v.SecondaryGateway4.Equal(other.SecondaryGateway4) {
		return false
	}

	if !v.SviNetflowMonitor.Equal(other.SviNetflowMonitor) {
		return false
	}

	if !v.Trm.Equal(other.Trm) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	if !v.VlanName.Equal(other.VlanName) {
		return false
	}

	if !v.VlanNetflowMonitor.Equal(other.VlanNetflowMonitor) {
		return false
	}

	if !v.VrfName.Equal(other.VrfName) {
		return false
	}

	return true
}

func (v NetworksValue) Type(ctx context.Context) attr.Type {
	return NetworksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetworksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"arp_suppression": basetypes.BoolType{},
		"attachments": basetypes.MapType{
			ElemType: AttachmentsValue{}.Type(ctx),
		},
		"deploy_attachments":     basetypes.BoolType{},
		"dhcp_relay_loopback_id": basetypes.Int64Type{},
		"dhcp_relay_servers": basetypes.ListType{
			ElemType: DhcpRelayServersValue{}.Type(ctx),
		},
		"display_name":               basetypes.StringType{},
		"gateway_ipv4_address":       basetypes.StringType{},
		"gateway_ipv6_address":       basetypes.StringType{},
		"igmp_version":               basetypes.StringType{},
		"ingress_replication":        basetypes.BoolType{},
		"interface_description":      basetypes.StringType{},
		"l3_gatway_border":           basetypes.BoolType{},
		"layer2_only":                basetypes.BoolType{},
		"mtu":                        basetypes.Int64Type{},
		"multicast_group":            basetypes.StringType{},
		"netflow":                    basetypes.BoolType{},
		"network_extension_template": basetypes.StringType{},
		"network_id":                 basetypes.Int64Type{},
		"network_status":             basetypes.StringType{},
		"network_template":           basetypes.StringType{},
		"network_type":               basetypes.StringType{},
		"primary_network_id":         basetypes.Int64Type{},
		"route_target_both":          basetypes.BoolType{},
		"routing_tag":                basetypes.Int64Type{},
		"secondary_gateway_1":        basetypes.StringType{},
		"secondary_gateway_2":        basetypes.StringType{},
		"secondary_gateway_3":        basetypes.StringType{},
		"secondary_gateway_4":        basetypes.StringType{},
		"svi_netflow_monitor":        basetypes.StringType{},
		"trm":                        basetypes.BoolType{},
		"vlan_id":                    basetypes.Int64Type{},
		"vlan_name":                  basetypes.StringType{},
		"vlan_netflow_monitor":       basetypes.StringType{},
		"vrf_name":                   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AttachmentsType{}

type AttachmentsType struct {
	basetypes.ObjectType
}

func (t AttachmentsType) Equal(o attr.Type) bool {
	other, ok := o.(AttachmentsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AttachmentsType) String() string {
	return "AttachmentsType"
}

func (t AttachmentsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	attachStateAttribute, ok := attributes["attach_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_state is missing from object`)

		return nil, diags
	}

	attachStateVal, ok := attachStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_state expected to be basetypes.StringValue, was: %T`, attachStateAttribute))
	}

	attachedAttribute, ok := attributes["attached"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attached is missing from object`)

		return nil, diags
	}

	attachedVal, ok := attachedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attached expected to be basetypes.BoolValue, was: %T`, attachedAttribute))
	}

	deployThisAttachmentAttribute, ok := attributes["deploy_this_attachment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deploy_this_attachment is missing from object`)

		return nil, diags
	}

	deployThisAttachmentVal, ok := deployThisAttachmentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deploy_this_attachment expected to be basetypes.BoolValue, was: %T`, deployThisAttachmentAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return nil, diags
	}

	displayNameVal, ok := displayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be basetypes.StringValue, was: %T`, displayNameAttribute))
	}

	freeformConfigAttribute, ok := attributes["freeform_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`freeform_config is missing from object`)

		return nil, diags
	}

	freeformConfigVal, ok := freeformConfigAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`freeform_config expected to be basetypes.StringValue, was: %T`, freeformConfigAttribute))
	}

	instanceValuesAttribute, ok := attributes["instance_values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_values is missing from object`)

		return nil, diags
	}

	instanceValuesVal, ok := instanceValuesAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_values expected to be basetypes.StringValue, was: %T`, instanceValuesAttribute))
	}

	switchNameAttribute, ok := attributes["switch_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`switch_name is missing from object`)

		return nil, diags
	}

	switchNameVal, ok := switchNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`switch_name expected to be basetypes.StringValue, was: %T`, switchNameAttribute))
	}

	switchPortsAttribute, ok := attributes["switch_ports"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`switch_ports is missing from object`)

		return nil, diags
	}

	switchPortsVal, ok := switchPortsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`switch_ports expected to be basetypes.SetValue, was: %T`, switchPortsAttribute))
	}

	torPortsAttribute, ok := attributes["tor_ports"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tor_ports is missing from object`)

		return nil, diags
	}

	torPortsVal, ok := torPortsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tor_ports expected to be basetypes.SetValue, was: %T`, torPortsAttribute))
	}

	vlanAttribute, ok := attributes["vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan is missing from object`)

		return nil, diags
	}

	vlanVal, ok := vlanAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan expected to be basetypes.Int64Value, was: %T`, vlanAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AttachmentsValue{
		AttachState:          attachStateVal,
		Attached:             attachedVal,
		DeployThisAttachment: deployThisAttachmentVal,
		DisplayName:          displayNameVal,
		FreeformConfig:       freeformConfigVal,
		InstanceValues:       instanceValuesVal,
		SwitchName:           switchNameVal,
		SwitchPorts:          switchPortsVal,
		TorPorts:             torPortsVal,
		Vlan:                 vlanVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewAttachmentsValueNull() AttachmentsValue {
	return AttachmentsValue{
		state: attr.ValueStateNull,
	}
}

func NewAttachmentsValueUnknown() AttachmentsValue {
	return AttachmentsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAttachmentsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AttachmentsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AttachmentsValue Attribute Value",
				"While creating a AttachmentsValue value, a missing attribute value was detected. "+
					"A AttachmentsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttachmentsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AttachmentsValue Attribute Type",
				"While creating a AttachmentsValue value, an invalid attribute value was detected. "+
					"A AttachmentsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttachmentsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AttachmentsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AttachmentsValue Attribute Value",
				"While creating a AttachmentsValue value, an extra attribute value was detected. "+
					"A AttachmentsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AttachmentsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAttachmentsValueUnknown(), diags
	}

	attachStateAttribute, ok := attributes["attach_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attach_state is missing from object`)

		return NewAttachmentsValueUnknown(), diags
	}

	attachStateVal, ok := attachStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attach_state expected to be basetypes.StringValue, was: %T`, attachStateAttribute))
	}

	attachedAttribute, ok := attributes["attached"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attached is missing from object`)

		return NewAttachmentsValueUnknown(), diags
	}

	attachedVal, ok := attachedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attached expected to be basetypes.BoolValue, was: %T`, attachedAttribute))
	}

	deployThisAttachmentAttribute, ok := attributes["deploy_this_attachment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deploy_this_attachment is missing from object`)

		return NewAttachmentsValueUnknown(), diags
	}

	deployThisAttachmentVal, ok := deployThisAttachmentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deploy_this_attachment expected to be basetypes.BoolValue, was: %T`, deployThisAttachmentAttribute))
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return NewAttachmentsValueUnknown(), diags
	}

	displayNameVal, ok := displayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be basetypes.StringValue, was: %T`, displayNameAttribute))
	}

	freeformConfigAttribute, ok := attributes["freeform_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`freeform_config is missing from object`)

		return NewAttachmentsValueUnknown(), diags
	}

	freeformConfigVal, ok := freeformConfigAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`freeform_config expected to be basetypes.StringValue, was: %T`, freeformConfigAttribute))
	}

	instanceValuesAttribute, ok := attributes["instance_values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance_values is missing from object`)

		return NewAttachmentsValueUnknown(), diags
	}

	instanceValuesVal, ok := instanceValuesAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance_values expected to be basetypes.StringValue, was: %T`, instanceValuesAttribute))
	}

	switchNameAttribute, ok := attributes["switch_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`switch_name is missing from object`)

		return NewAttachmentsValueUnknown(), diags
	}

	switchNameVal, ok := switchNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`switch_name expected to be basetypes.StringValue, was: %T`, switchNameAttribute))
	}

	switchPortsAttribute, ok := attributes["switch_ports"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`switch_ports is missing from object`)

		return NewAttachmentsValueUnknown(), diags
	}

	switchPortsVal, ok := switchPortsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`switch_ports expected to be basetypes.SetValue, was: %T`, switchPortsAttribute))
	}

	torPortsAttribute, ok := attributes["tor_ports"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tor_ports is missing from object`)

		return NewAttachmentsValueUnknown(), diags
	}

	torPortsVal, ok := torPortsAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tor_ports expected to be basetypes.SetValue, was: %T`, torPortsAttribute))
	}

	vlanAttribute, ok := attributes["vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan is missing from object`)

		return NewAttachmentsValueUnknown(), diags
	}

	vlanVal, ok := vlanAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan expected to be basetypes.Int64Value, was: %T`, vlanAttribute))
	}

	if diags.HasError() {
		return NewAttachmentsValueUnknown(), diags
	}

	return AttachmentsValue{
		AttachState:          attachStateVal,
		Attached:             attachedVal,
		DeployThisAttachment: deployThisAttachmentVal,
		DisplayName:          displayNameVal,
		FreeformConfig:       freeformConfigVal,
		InstanceValues:       instanceValuesVal,
		SwitchName:           switchNameVal,
		SwitchPorts:          switchPortsVal,
		TorPorts:             torPortsVal,
		Vlan:                 vlanVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewAttachmentsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AttachmentsValue {
	object, diags := NewAttachmentsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAttachmentsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AttachmentsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAttachmentsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAttachmentsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAttachmentsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAttachmentsValueMust(AttachmentsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AttachmentsType) ValueType(ctx context.Context) attr.Value {
	return AttachmentsValue{}
}

var _ basetypes.ObjectValuable = AttachmentsValue{}

type AttachmentsValue struct {
	AttachState          basetypes.StringValue `tfsdk:"attach_state"`
	Attached             basetypes.BoolValue   `tfsdk:"attached"`
	DeployThisAttachment basetypes.BoolValue   `tfsdk:"deploy_this_attachment"`
	DisplayName          basetypes.StringValue `tfsdk:"display_name"`
	FreeformConfig       basetypes.StringValue `tfsdk:"freeform_config"`
	InstanceValues       basetypes.StringValue `tfsdk:"instance_values"`
	SwitchName           basetypes.StringValue `tfsdk:"switch_name"`
	SwitchPorts          basetypes.SetValue    `tfsdk:"switch_ports"`
	TorPorts             basetypes.SetValue    `tfsdk:"tor_ports"`
	Vlan                 basetypes.Int64Value  `tfsdk:"vlan"`
	state                attr.ValueState
}

func (v AttachmentsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["attach_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["attached"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["deploy_this_attachment"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["freeform_config"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["instance_values"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["switch_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["switch_ports"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["tor_ports"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["vlan"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.AttachState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attach_state"] = val

		val, err = v.Attached.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attached"] = val

		val, err = v.DeployThisAttachment.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deploy_this_attachment"] = val

		val, err = v.DisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display_name"] = val

		val, err = v.FreeformConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["freeform_config"] = val

		val, err = v.InstanceValues.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance_values"] = val

		val, err = v.SwitchName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["switch_name"] = val

		val, err = v.SwitchPorts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["switch_ports"] = val

		val, err = v.TorPorts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tor_ports"] = val

		val, err = v.Vlan.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AttachmentsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AttachmentsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AttachmentsValue) String() string {
	return "AttachmentsValue"
}

func (v AttachmentsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	switchPortsVal, d := types.SetValue(types.StringType, v.SwitchPorts.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"attach_state":           basetypes.StringType{},
			"attached":               basetypes.BoolType{},
			"deploy_this_attachment": basetypes.BoolType{},
			"display_name":           basetypes.StringType{},
			"freeform_config":        basetypes.StringType{},
			"instance_values":        basetypes.StringType{},
			"switch_name":            basetypes.StringType{},
			"switch_ports": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tor_ports": basetypes.SetType{
				ElemType: types.StringType,
			},
			"vlan": basetypes.Int64Type{},
		}), diags
	}

	torPortsVal, d := types.SetValue(types.StringType, v.TorPorts.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"attach_state":           basetypes.StringType{},
			"attached":               basetypes.BoolType{},
			"deploy_this_attachment": basetypes.BoolType{},
			"display_name":           basetypes.StringType{},
			"freeform_config":        basetypes.StringType{},
			"instance_values":        basetypes.StringType{},
			"switch_name":            basetypes.StringType{},
			"switch_ports": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tor_ports": basetypes.SetType{
				ElemType: types.StringType,
			},
			"vlan": basetypes.Int64Type{},
		}), diags
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"attach_state":           basetypes.StringType{},
			"attached":               basetypes.BoolType{},
			"deploy_this_attachment": basetypes.BoolType{},
			"display_name":           basetypes.StringType{},
			"freeform_config":        basetypes.StringType{},
			"instance_values":        basetypes.StringType{},
			"switch_name":            basetypes.StringType{},
			"switch_ports": basetypes.SetType{
				ElemType: types.StringType,
			},
			"tor_ports": basetypes.SetType{
				ElemType: types.StringType,
			},
			"vlan": basetypes.Int64Type{},
		},
		map[string]attr.Value{
			"attach_state":           v.AttachState,
			"attached":               v.Attached,
			"deploy_this_attachment": v.DeployThisAttachment,
			"display_name":           v.DisplayName,
			"freeform_config":        v.FreeformConfig,
			"instance_values":        v.InstanceValues,
			"switch_name":            v.SwitchName,
			"switch_ports":           switchPortsVal,
			"tor_ports":              torPortsVal,
			"vlan":                   v.Vlan,
		})

	return objVal, diags
}

func (v AttachmentsValue) Equal(o attr.Value) bool {
	other, ok := o.(AttachmentsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AttachState.Equal(other.AttachState) {
		return false
	}

	if !v.Attached.Equal(other.Attached) {
		return false
	}

	if !v.DeployThisAttachment.Equal(other.DeployThisAttachment) {
		return false
	}

	if !v.DisplayName.Equal(other.DisplayName) {
		return false
	}

	if !v.FreeformConfig.Equal(other.FreeformConfig) {
		return false
	}

	if !v.InstanceValues.Equal(other.InstanceValues) {
		return false
	}

	if !v.SwitchName.Equal(other.SwitchName) {
		return false
	}

	if !v.SwitchPorts.Equal(other.SwitchPorts) {
		return false
	}

	if !v.TorPorts.Equal(other.TorPorts) {
		return false
	}

	if !v.Vlan.Equal(other.Vlan) {
		return false
	}

	return true
}

func (v AttachmentsValue) Type(ctx context.Context) attr.Type {
	return AttachmentsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AttachmentsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"attach_state":           basetypes.StringType{},
		"attached":               basetypes.BoolType{},
		"deploy_this_attachment": basetypes.BoolType{},
		"display_name":           basetypes.StringType{},
		"freeform_config":        basetypes.StringType{},
		"instance_values":        basetypes.StringType{},
		"switch_name":            basetypes.StringType{},
		"switch_ports": basetypes.SetType{
			ElemType: types.StringType,
		},
		"tor_ports": basetypes.SetType{
			ElemType: types.StringType,
		},
		"vlan": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = DhcpRelayServersType{}

type DhcpRelayServersType struct {
	basetypes.ObjectType
}

func (t DhcpRelayServersType) Equal(o attr.Type) bool {
	other, ok := o.(DhcpRelayServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DhcpRelayServersType) String() string {
	return "DhcpRelayServersType"
}

func (t DhcpRelayServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressAttribute, ok := attributes["address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address is missing from object`)

		return nil, diags
	}

	addressVal, ok := addressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address expected to be basetypes.StringValue, was: %T`, addressAttribute))
	}

	vrfAttribute, ok := attributes["vrf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf is missing from object`)

		return nil, diags
	}

	vrfVal, ok := vrfAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf expected to be basetypes.StringValue, was: %T`, vrfAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DhcpRelayServersValue{
		Address: addressVal,
		Vrf:     vrfVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewDhcpRelayServersValueNull() DhcpRelayServersValue {
	return DhcpRelayServersValue{
		state: attr.ValueStateNull,
	}
}

func NewDhcpRelayServersValueUnknown() DhcpRelayServersValue {
	return DhcpRelayServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDhcpRelayServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DhcpRelayServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DhcpRelayServersValue Attribute Value",
				"While creating a DhcpRelayServersValue value, a missing attribute value was detected. "+
					"A DhcpRelayServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DhcpRelayServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DhcpRelayServersValue Attribute Type",
				"While creating a DhcpRelayServersValue value, an invalid attribute value was detected. "+
					"A DhcpRelayServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DhcpRelayServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DhcpRelayServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DhcpRelayServersValue Attribute Value",
				"While creating a DhcpRelayServersValue value, an extra attribute value was detected. "+
					"A DhcpRelayServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DhcpRelayServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDhcpRelayServersValueUnknown(), diags
	}

	addressAttribute, ok := attributes["address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address is missing from object`)

		return NewDhcpRelayServersValueUnknown(), diags
	}

	addressVal, ok := addressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address expected to be basetypes.StringValue, was: %T`, addressAttribute))
	}

	vrfAttribute, ok := attributes["vrf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf is missing from object`)

		return NewDhcpRelayServersValueUnknown(), diags
	}

	vrfVal, ok := vrfAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf expected to be basetypes.StringValue, was: %T`, vrfAttribute))
	}

	if diags.HasError() {
		return NewDhcpRelayServersValueUnknown(), diags
	}

	return DhcpRelayServersValue{
		Address: addressVal,
		Vrf:     vrfVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewDhcpRelayServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DhcpRelayServersValue {
	object, diags := NewDhcpRelayServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDhcpRelayServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DhcpRelayServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDhcpRelayServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDhcpRelayServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDhcpRelayServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDhcpRelayServersValueMust(DhcpRelayServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DhcpRelayServersType) ValueType(ctx context.Context) attr.Value {
	return DhcpRelayServersValue{}
}

var _ basetypes.ObjectValuable = DhcpRelayServersValue{}

type DhcpRelayServersValue struct {
	Address basetypes.StringValue `tfsdk:"address"`
	Vrf     basetypes.StringValue `tfsdk:"vrf"`
	state   attr.ValueState
}

func (v DhcpRelayServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vrf"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Address.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address"] = val

		val, err = v.Vrf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DhcpRelayServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DhcpRelayServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DhcpRelayServersValue) String() string {
	return "DhcpRelayServersValue"
}

func (v DhcpRelayServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"address": basetypes.StringType{},
			"vrf":     basetypes.StringType{},
		},
		map[string]attr.Value{
			"address": v.Address,
			"vrf":     v.Vrf,
		})

	return objVal, diags
}

func (v DhcpRelayServersValue) Equal(o attr.Value) bool {
	other, ok := o.(DhcpRelayServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Address.Equal(other.Address) {
		return false
	}

	if !v.Vrf.Equal(other.Vrf) {
		return false
	}

	return true
}

func (v DhcpRelayServersValue) Type(ctx context.Context) attr.Type {
	return DhcpRelayServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DhcpRelayServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"address": basetypes.StringType{},
		"vrf":     basetypes.StringType{},
	}
}
