// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Mozilla Public License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://mozilla.org/MPL/2.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: MPL-2.0

// Code generated by "gen/generator.go"; DO NOT EDIT.

package provider

//template:begin imports
import (
	"context"
	"fmt"
	"net/url"

	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"
)

//template:end imports

//template:begin types
type Network struct {
	Id                       types.String              `tfsdk:"id"`
	FabricName               types.String              `tfsdk:"fabric_name"`
	NetworkName              types.String              `tfsdk:"network_name"`
	DisplayName              types.String              `tfsdk:"display_name"`
	NetworkId                types.Int64               `tfsdk:"network_id"`
	NetworkTemplate          types.String              `tfsdk:"network_template"`
	NetworkExtensionTemplate types.String              `tfsdk:"network_extension_template"`
	VrfName                  types.String              `tfsdk:"vrf_name"`
	GatewayIpv4Address       types.String              `tfsdk:"gateway_ipv4_address"`
	VlanId                   types.Int64               `tfsdk:"vlan_id"`
	GatewayIpv6Address       types.String              `tfsdk:"gateway_ipv6_address"`
	Layer2Only               types.Bool                `tfsdk:"layer2_only"`
	ArpSuppression           types.Bool                `tfsdk:"arp_suppression"`
	IngressReplication       types.Bool                `tfsdk:"ingress_replication"`
	MulticastGroup           types.String              `tfsdk:"multicast_group"`
	DhcpRelayServers         []NetworkDhcpRelayServers `tfsdk:"dhcp_relay_servers"`
	DhcpRelayLoopbackId      types.Int64               `tfsdk:"dhcp_relay_loopback_id"`
	VlanName                 types.String              `tfsdk:"vlan_name"`
	InterfaceDescription     types.String              `tfsdk:"interface_description"`
	Mtu                      types.Int64               `tfsdk:"mtu"`
	LoopbackRoutingTag       types.Int64               `tfsdk:"loopback_routing_tag"`
	Trm                      types.Bool                `tfsdk:"trm"`
	SecondaryGateway1        types.String              `tfsdk:"secondary_gateway_1"`
	SecondaryGateway2        types.String              `tfsdk:"secondary_gateway_2"`
	SecondaryGateway3        types.String              `tfsdk:"secondary_gateway_3"`
	SecondaryGateway4        types.String              `tfsdk:"secondary_gateway_4"`
	RouteTargetBoth          types.Bool                `tfsdk:"route_target_both"`
	Netflow                  types.Bool                `tfsdk:"netflow"`
	SviNetflowMonitor        types.String              `tfsdk:"svi_netflow_monitor"`
	VlanNetflowMonitor       types.String              `tfsdk:"vlan_netflow_monitor"`
	L3GatwayBorder           types.Bool                `tfsdk:"l3_gatway_border"`
	Attachments              []NetworkAttachments      `tfsdk:"attachments"`
}

type NetworkDhcpRelayServers struct {
	Address types.String `tfsdk:"address"`
	Vrf     types.String `tfsdk:"vrf"`
}

type NetworkAttachments struct {
	SerialNumber      types.String `tfsdk:"serial_number"`
	AttachSwitchPorts types.String `tfsdk:"attach_switch_ports"`
	DetachSwitchPorts types.String `tfsdk:"detach_switch_ports"`
	VlanId            types.Int64  `tfsdk:"vlan_id"`
	FreeformConfig    types.String `tfsdk:"freeform_config"`
}

//template:end types

//template:begin getPath
func (data Network) getPath() string {
	return fmt.Sprintf("/lan-fabric/rest/top-down/v2/fabrics/%v/networks/", url.QueryEscape(fmt.Sprintf("%v", data.FabricName.ValueString())))
}

//template:end getPath

func (data Network) toBody(ctx context.Context) string {
	body := ""
	if !data.FabricName.IsNull() && !data.FabricName.IsUnknown() {
		body, _ = sjson.Set(body, "fabric", data.FabricName.ValueString())
	}
	if !data.NetworkName.IsNull() && !data.NetworkName.IsUnknown() {
		body, _ = sjson.Set(body, "networkName", data.NetworkName.ValueString())
	}
	if !data.DisplayName.IsNull() && !data.DisplayName.IsUnknown() {
		body, _ = sjson.Set(body, "displayName", data.DisplayName.ValueString())
	}
	if !data.NetworkId.IsNull() && !data.NetworkId.IsUnknown() {
		body, _ = sjson.Set(body, "networkId", data.NetworkId.ValueInt64())
	}
	if !data.NetworkTemplate.IsNull() && !data.NetworkTemplate.IsUnknown() {
		body, _ = sjson.Set(body, "networkTemplate", data.NetworkTemplate.ValueString())
	}
	if !data.NetworkExtensionTemplate.IsNull() && !data.NetworkExtensionTemplate.IsUnknown() {
		body, _ = sjson.Set(body, "networkExtensionTemplate", data.NetworkExtensionTemplate.ValueString())
	}
	if !data.VrfName.IsNull() && !data.VrfName.IsUnknown() {
		body, _ = sjson.Set(body, "vrf", data.VrfName.ValueString())
	}
	if !data.GatewayIpv4Address.IsNull() && !data.GatewayIpv4Address.IsUnknown() {
		body, _ = sjson.Set(body, "networkTemplateConfig.gatewayIpAddress", data.GatewayIpv4Address.ValueString())
	}
	if !data.VlanId.IsNull() && !data.VlanId.IsUnknown() {
		body, _ = sjson.Set(body, "networkTemplateConfig.vlanId", data.VlanId.ValueInt64())
	}
	if !data.GatewayIpv6Address.IsNull() && !data.GatewayIpv6Address.IsUnknown() {
		body, _ = sjson.Set(body, "networkTemplateConfig.gatewayIpV6Address", data.GatewayIpv6Address.ValueString())
	}
	if !data.Layer2Only.IsNull() && !data.Layer2Only.IsUnknown() {
		body, _ = sjson.Set(body, "networkTemplateConfig.isLayer2Only", data.Layer2Only.ValueBool())
	}
	if !data.ArpSuppression.IsNull() && !data.ArpSuppression.IsUnknown() {
		body, _ = sjson.Set(body, "networkTemplateConfig.suppressArp", data.ArpSuppression.ValueBool())
	}
	if !data.IngressReplication.IsNull() && !data.IngressReplication.IsUnknown() {
		body, _ = sjson.Set(body, "networkTemplateConfig.enableIR", data.IngressReplication.ValueBool())
	}
	if !data.MulticastGroup.IsNull() && !data.MulticastGroup.IsUnknown() {
		body, _ = sjson.Set(body, "networkTemplateConfig.mcastGroup", data.MulticastGroup.ValueString())
	}
	if len(data.DhcpRelayServers) > 0 {
		body, _ = sjson.Set(body, "networkTemplateConfig.dhcpServers.dhcpServers", []interface{}{})
		for _, item := range data.DhcpRelayServers {
			itemBody := ""
			if !item.Address.IsNull() && !item.Address.IsUnknown() {
				itemBody, _ = sjson.Set(itemBody, "srvrAddr", item.Address.ValueString())
			}
			if !item.Vrf.IsNull() && !item.Vrf.IsUnknown() {
				itemBody, _ = sjson.Set(itemBody, "srvrVrf", item.Vrf.ValueString())
			}
			body, _ = sjson.SetRaw(body, "networkTemplateConfig.dhcpServers.dhcpServers.-1", itemBody)
		}
	}
	if !data.DhcpRelayLoopbackId.IsNull() && !data.DhcpRelayLoopbackId.IsUnknown() {
		body, _ = sjson.Set(body, "networkTemplateConfig.loopbackId", data.DhcpRelayLoopbackId.ValueInt64())
	}
	if !data.VlanName.IsNull() && !data.VlanName.IsUnknown() {
		body, _ = sjson.Set(body, "networkTemplateConfig.vrfVlanName", data.VlanName.ValueString())
	}
	if !data.InterfaceDescription.IsNull() && !data.InterfaceDescription.IsUnknown() {
		body, _ = sjson.Set(body, "networkTemplateConfig.intfDescription", data.InterfaceDescription.ValueString())
	}
	if !data.Mtu.IsNull() && !data.Mtu.IsUnknown() {
		body, _ = sjson.Set(body, "networkTemplateConfig.mtu", data.Mtu.ValueInt64())
	}
	if !data.LoopbackRoutingTag.IsNull() && !data.LoopbackRoutingTag.IsUnknown() {
		body, _ = sjson.Set(body, "networkTemplateConfig.tag", data.LoopbackRoutingTag.ValueInt64())
	}
	if !data.Trm.IsNull() && !data.Trm.IsUnknown() {
		body, _ = sjson.Set(body, "networkTemplateConfig.trmEnabled", data.Trm.ValueBool())
	}
	if !data.SecondaryGateway1.IsNull() && !data.SecondaryGateway1.IsUnknown() {
		body, _ = sjson.Set(body, "networkTemplateConfig.secondaryGW1", data.SecondaryGateway1.ValueString())
	}
	if !data.SecondaryGateway2.IsNull() && !data.SecondaryGateway2.IsUnknown() {
		body, _ = sjson.Set(body, "networkTemplateConfig.secondaryGW2", data.SecondaryGateway2.ValueString())
	}
	if !data.SecondaryGateway3.IsNull() && !data.SecondaryGateway3.IsUnknown() {
		body, _ = sjson.Set(body, "networkTemplateConfig.secondaryGW3", data.SecondaryGateway3.ValueString())
	}
	if !data.SecondaryGateway4.IsNull() && !data.SecondaryGateway4.IsUnknown() {
		body, _ = sjson.Set(body, "networkTemplateConfig.secondaryGW4", data.SecondaryGateway4.ValueString())
	}
	if !data.RouteTargetBoth.IsNull() && !data.RouteTargetBoth.IsUnknown() {
		body, _ = sjson.Set(body, "networkTemplateConfig.rtBothAuto", data.RouteTargetBoth.ValueBool())
	}
	if !data.Netflow.IsNull() && !data.Netflow.IsUnknown() {
		body, _ = sjson.Set(body, "networkTemplateConfig.ENABLE_NETFLOW", data.Netflow.ValueBool())
	}
	if !data.SviNetflowMonitor.IsNull() && !data.SviNetflowMonitor.IsUnknown() {
		body, _ = sjson.Set(body, "networkTemplateConfig.SVI_NETFLOW_MONITOR", data.SviNetflowMonitor.ValueString())
	}
	if !data.VlanNetflowMonitor.IsNull() && !data.VlanNetflowMonitor.IsUnknown() {
		body, _ = sjson.Set(body, "networkTemplateConfig.VLAN_NETFLOW_MONITOR", data.VlanNetflowMonitor.ValueString())
	}
	if !data.L3GatwayBorder.IsNull() && !data.L3GatwayBorder.IsUnknown() {
		body, _ = sjson.Set(body, "networkTemplateConfig.enableL3OnBorder", data.L3GatwayBorder.ValueBool())
	}
	return body
}

func (data Network) toBodyAttachments(ctx context.Context, attachments gjson.Result) string {
	body := ""
	body, _ = sjson.Set(body, "0.networkName", data.NetworkName.ValueString())
	body, _ = sjson.Set(body, "0.lanAttachList", []interface{}{})
	attachments.Get("0.lanAttachList").ForEach(func(k, v gjson.Result) bool {
		serialNumber := v.Get("switchSerialNo").String()

		itemBody := ""
		if !data.FabricName.IsNull() && !data.FabricName.IsUnknown() {
			itemBody, _ = sjson.Set(itemBody, "fabric", data.FabricName.ValueString())
		}
		if !data.NetworkName.IsNull() && !data.NetworkName.IsUnknown() {
			itemBody, _ = sjson.Set(itemBody, "networkName", data.NetworkName.ValueString())
		}
		found := false
		for _, item := range data.Attachments {
			if item.SerialNumber.ValueString() == serialNumber {
				found = true
				if !item.SerialNumber.IsNull() && !item.SerialNumber.IsUnknown() {
					itemBody, _ = sjson.Set(itemBody, "serialNumber", item.SerialNumber.ValueString())
				}
				if !item.AttachSwitchPorts.IsNull() && !item.AttachSwitchPorts.IsUnknown() {
					itemBody, _ = sjson.Set(itemBody, "switchPorts", item.AttachSwitchPorts.ValueString())
				}
				if !item.DetachSwitchPorts.IsNull() && !item.DetachSwitchPorts.IsUnknown() {
					itemBody, _ = sjson.Set(itemBody, "detachSwitchPorts", item.DetachSwitchPorts.ValueString())
				}
				if !item.VlanId.IsNull() && !item.VlanId.IsUnknown() {
					itemBody, _ = sjson.Set(itemBody, "vlan", item.VlanId.ValueInt64())
				}
				if !item.FreeformConfig.IsNull() && !item.FreeformConfig.IsUnknown() {
					itemBody, _ = sjson.Set(itemBody, "freeformConfig", item.FreeformConfig.ValueString())
				}
				itemBody, _ = sjson.Set(itemBody, "deployment", true)
			}
		}
		if !found {
			itemBody, _ = sjson.Set(itemBody, "serialNumber", serialNumber)
			itemBody, _ = sjson.Set(itemBody, "vlan", v.Get("vlanId").Int())
			itemBody, _ = sjson.Set(itemBody, "deployment", false)
		}
		body, _ = sjson.SetRaw(body, "0.lanAttachList.-1", itemBody)

		return true // keep iterating
	})
	return body
}

func (data *Network) fromBody(ctx context.Context, res gjson.Result) {
	if value := res.Get("fabric"); value.Exists() && value.String() != "" {
		data.FabricName = types.StringValue(value.String())
	} else {
		data.FabricName = types.StringNull()
	}
	if value := res.Get("networkName"); value.Exists() && value.String() != "" {
		data.NetworkName = types.StringValue(value.String())
	} else {
		data.NetworkName = types.StringNull()
	}
	if value := res.Get("displayName"); value.Exists() && value.String() != "" {
		data.DisplayName = types.StringValue(value.String())
	} else {
		data.DisplayName = types.StringNull()
	}
	if value := res.Get("networkId"); value.Exists() && value.String() != "" {
		data.NetworkId = types.Int64Value(value.Int())
	} else {
		data.NetworkId = types.Int64Null()
	}
	if value := res.Get("networkTemplate"); value.Exists() && value.String() != "" {
		data.NetworkTemplate = types.StringValue(value.String())
	} else {
		data.NetworkTemplate = types.StringNull()
	}
	if value := res.Get("networkExtensionTemplate"); value.Exists() && value.String() != "" {
		data.NetworkExtensionTemplate = types.StringValue(value.String())
	} else {
		data.NetworkExtensionTemplate = types.StringNull()
	}
	if value := res.Get("vrf"); value.Exists() && value.String() != "" {
		data.VrfName = types.StringValue(value.String())
	} else {
		data.VrfName = types.StringNull()
	}
	if value := res.Get("networkTemplateConfig.gatewayIpAddress"); value.Exists() && value.String() != "" {
		data.GatewayIpv4Address = types.StringValue(value.String())
	} else {
		data.GatewayIpv4Address = types.StringNull()
	}
	if value := res.Get("networkTemplateConfig.vlanId"); value.Exists() && value.String() != "" {
		data.VlanId = types.Int64Value(value.Int())
	} else {
		data.VlanId = types.Int64Null()
	}
	if value := res.Get("networkTemplateConfig.gatewayIpV6Address"); value.Exists() && value.String() != "" {
		data.GatewayIpv6Address = types.StringValue(value.String())
	} else {
		data.GatewayIpv6Address = types.StringNull()
	}
	if value := res.Get("networkTemplateConfig.isLayer2Only"); value.Exists() && value.String() != "" {
		data.Layer2Only = types.BoolValue(value.Bool())
	} else {
		data.Layer2Only = types.BoolNull()
	}
	if value := res.Get("networkTemplateConfig.suppressArp"); value.Exists() && value.String() != "" {
		data.ArpSuppression = types.BoolValue(value.Bool())
	} else {
		data.ArpSuppression = types.BoolNull()
	}
	if value := res.Get("networkTemplateConfig.enableIR"); value.Exists() && value.String() != "" {
		data.IngressReplication = types.BoolValue(value.Bool())
	} else {
		data.IngressReplication = types.BoolNull()
	}
	if value := res.Get("networkTemplateConfig.mcastGroup"); value.Exists() && value.String() != "" {
		data.MulticastGroup = types.StringValue(value.String())
	} else {
		data.MulticastGroup = types.StringNull()
	}
	if value := res.Get("networkTemplateConfig.dhcpServers.dhcpServers"); value.Exists() && value.String() != "" {
		data.DhcpRelayServers = make([]NetworkDhcpRelayServers, 0)
		value.ForEach(func(k, v gjson.Result) bool {
			item := NetworkDhcpRelayServers{}
			if cValue := v.Get("srvrAddr"); cValue.Exists() && cValue.String() != "" {
				item.Address = types.StringValue(cValue.String())
			} else {
				item.Address = types.StringNull()
			}
			if cValue := v.Get("srvrVrf"); cValue.Exists() && cValue.String() != "" {
				item.Vrf = types.StringValue(cValue.String())
			} else {
				item.Vrf = types.StringNull()
			}
			data.DhcpRelayServers = append(data.DhcpRelayServers, item)
			return true
		})
	}
	if value := res.Get("networkTemplateConfig.loopbackId"); value.Exists() && value.String() != "" {
		data.DhcpRelayLoopbackId = types.Int64Value(value.Int())
	} else {
		data.DhcpRelayLoopbackId = types.Int64Null()
	}
	if value := res.Get("networkTemplateConfig.vrfVlanName"); value.Exists() && value.String() != "" {
		data.VlanName = types.StringValue(value.String())
	} else {
		data.VlanName = types.StringNull()
	}
	if value := res.Get("networkTemplateConfig.intfDescription"); value.Exists() && value.String() != "" {
		data.InterfaceDescription = types.StringValue(value.String())
	} else {
		data.InterfaceDescription = types.StringNull()
	}
	if value := res.Get("networkTemplateConfig.mtu"); value.Exists() && value.String() != "" {
		data.Mtu = types.Int64Value(value.Int())
	} else {
		data.Mtu = types.Int64Null()
	}
	if value := res.Get("networkTemplateConfig.tag"); value.Exists() && value.String() != "" {
		data.LoopbackRoutingTag = types.Int64Value(value.Int())
	} else {
		data.LoopbackRoutingTag = types.Int64Null()
	}
	if value := res.Get("networkTemplateConfig.trmEnabled"); value.Exists() && value.String() != "" {
		data.Trm = types.BoolValue(value.Bool())
	} else {
		data.Trm = types.BoolNull()
	}
	if value := res.Get("networkTemplateConfig.secondaryGW1"); value.Exists() && value.String() != "" {
		data.SecondaryGateway1 = types.StringValue(value.String())
	} else {
		data.SecondaryGateway1 = types.StringNull()
	}
	if value := res.Get("networkTemplateConfig.secondaryGW2"); value.Exists() && value.String() != "" {
		data.SecondaryGateway2 = types.StringValue(value.String())
	} else {
		data.SecondaryGateway2 = types.StringNull()
	}
	if value := res.Get("networkTemplateConfig.secondaryGW3"); value.Exists() && value.String() != "" {
		data.SecondaryGateway3 = types.StringValue(value.String())
	} else {
		data.SecondaryGateway3 = types.StringNull()
	}
	if value := res.Get("networkTemplateConfig.secondaryGW4"); value.Exists() && value.String() != "" {
		data.SecondaryGateway4 = types.StringValue(value.String())
	} else {
		data.SecondaryGateway4 = types.StringNull()
	}
	if value := res.Get("networkTemplateConfig.rtBothAuto"); value.Exists() && value.String() != "" {
		data.RouteTargetBoth = types.BoolValue(value.Bool())
	} else {
		data.RouteTargetBoth = types.BoolNull()
	}
	if value := res.Get("networkTemplateConfig.ENABLE_NETFLOW"); value.Exists() && value.String() != "" {
		data.Netflow = types.BoolValue(value.Bool())
	} else {
		data.Netflow = types.BoolNull()
	}
	if value := res.Get("networkTemplateConfig.SVI_NETFLOW_MONITOR"); value.Exists() && value.String() != "" {
		data.SviNetflowMonitor = types.StringValue(value.String())
	} else {
		data.SviNetflowMonitor = types.StringNull()
	}
	if value := res.Get("networkTemplateConfig.VLAN_NETFLOW_MONITOR"); value.Exists() && value.String() != "" {
		data.VlanNetflowMonitor = types.StringValue(value.String())
	} else {
		data.VlanNetflowMonitor = types.StringNull()
	}
	if value := res.Get("networkTemplateConfig.enableL3OnBorder"); value.Exists() && value.String() != "" {
		data.L3GatwayBorder = types.BoolValue(value.Bool())
	} else {
		data.L3GatwayBorder = types.BoolNull()
	}
}

func (data *Network) fromBodyAttachments(ctx context.Context, res gjson.Result, all bool) {
	serialsToRemove := []string{}
	res.Get("0.lanAttachList").ForEach(func(k, v gjson.Result) bool {
		serialNumber := v.Get("switchSerialNo").String()
		attached := v.Get("isLanAttached").Bool()
		if all {
			if attached {
				var item NetworkAttachments
				if value := v.Get("switchSerialNo"); value.Exists() {
					item.SerialNumber = types.StringValue(value.String())
				} else {
					item.SerialNumber = types.StringNull()
				}
				if value := v.Get("portNames"); value.Exists() {
					item.AttachSwitchPorts = types.StringValue(value.String())
				} else {
					item.AttachSwitchPorts = types.StringNull()
				}
				if value := v.Get("vlanId"); value.Exists() {
					item.VlanId = types.Int64Value(value.Int())
				} else {
					item.VlanId = types.Int64Null()
				}
				data.Attachments = append(data.Attachments, item)
			}
		} else {
			for _, item := range data.Attachments {
				if item.SerialNumber.ValueString() == serialNumber {
					if attached {
						if value := v.Get("vlanId"); value.Exists() {
							item.VlanId = types.Int64Value(value.Int())
						} else {
							item.VlanId = types.Int64Null()
						}
						if value := v.Get("portNames"); value.Exists() {
							item.AttachSwitchPorts = types.StringValue(value.String())
						} else {
							item.AttachSwitchPorts = types.StringNull()
						}
					} else {
						serialsToRemove = append(serialsToRemove, serialNumber)
					}
				}
			}
		}
		return true
	})
	for i := range data.Attachments {
		for _, serial := range serialsToRemove {
			if data.Attachments[i].SerialNumber.ValueString() == serial {
				data.Attachments = append(data.Attachments[:i], data.Attachments[i+1:]...)
				break
			}
		}
	}
}
